(self.webpackChunkreact_bootstrap_website =
  self.webpackChunkreact_bootstrap_website || []).push([
  [7918],
  {
    2801: (e, n, t) => {
      var o = {
        "./AbstractModalHeader.json": [30344, 344],
        "./Accordion.json": [16012, 6012],
        "./AccordionBody.json": [71317, 1317],
        "./AccordionButton.json": [38706, 8706],
        "./AccordionCollapse.json": [76391, 6391],
        "./AccordionHeader.json": [20632, 632],
        "./AccordionItem.json": [18593, 8593],
        "./Alert.json": [15633, 5633],
        "./AlertHeading.json": [39903, 9903],
        "./AlertLink.json": [83402, 3402],
        "./BackdropTransition.json": [90014, 14],
        "./Badge.json": [66953, 6953],
        "./Breadcrumb.json": [66452, 6452],
        "./BreadcrumbItem.json": [51418, 1418],
        "./BsPrefixComponent.json": [29480, 9480],
        "./Button.json": [67021, 7021],
        "./ButtonGroup.json": [51513, 1513],
        "./ButtonToolbar.json": [9899, 9899],
        "./Card.json": [48561, 8561],
        "./CardBody.json": [5898, 5898],
        "./CardFooter.json": [8964, 8964],
        "./CardGroup.json": [97973, 7973],
        "./CardHeader.json": [83038, 3038],
        "./CardImg.json": [65647, 5647],
        "./CardImgOverlay.json": [31503, 1503],
        "./CardLink.json": [82819, 2819],
        "./CardSubtitle.json": [12153, 2153],
        "./CardText.json": [33915, 3915],
        "./CardTitle.json": [36899, 6899],
        "./Carousel.json": [34559, 4559],
        "./CarouselCaption.json": [57254, 7254],
        "./CarouselItem.json": [13283, 3283],
        "./CloseButton.json": [54926, 4926],
        "./Col.json": [24123, 4123],
        "./Collapse.json": [95020, 5020],
        "./Container.json": [83941, 3941],
        "./DialogTransition.json": [19202, 9202],
        "./Dropdown.json": [40945, 945],
        "./DropdownButton.json": [40585, 585],
        "./DropdownDivider.json": [53995, 3995],
        "./DropdownHeader.json": [39172, 9172],
        "./DropdownItem.json": [55820, 5820],
        "./DropdownItemText.json": [42224, 2224],
        "./DropdownMenu.json": [97091, 7091],
        "./DropdownToggle.json": [35108, 5108],
        "./Fade.json": [6239, 6239],
        "./Feedback.json": [84479, 4479],
        "./Figure.json": [59525, 9525],
        "./FigureCaption.json": [18213, 8213],
        "./FigureImage.json": [5169, 5169],
        "./FloatingLabel.json": [17287, 7287],
        "./Form.json": [26820, 6820],
        "./FormCheck.json": [66371, 6371],
        "./FormCheckInput.json": [62680, 2680],
        "./FormCheckLabel.json": [83482, 3482],
        "./FormControl.json": [44913, 4913],
        "./FormFloating.json": [75364, 5364],
        "./FormGroup.json": [82345, 2345],
        "./FormLabel.json": [72377, 2377],
        "./FormRange.json": [83372, 3372],
        "./FormSelect.json": [29886, 9886],
        "./FormText.json": [95854, 5854],
        "./Image.json": [54319, 4319],
        "./InputGroup.json": [12284, 2284],
        "./InputGroupCheckbox.json": [2869, 2869],
        "./InputGroupRadio.json": [1105, 1105],
        "./InputGroupText.json": [23344, 3344],
        "./ListGroup.json": [26256, 6256],
        "./ListGroupItem.json": [71227, 1227],
        "./Modal.json": [22808, 2808],
        "./ModalBody.json": [31434, 1434],
        "./ModalDialog.json": [72727, 2727],
        "./ModalFooter.json": [28112, 8112],
        "./ModalHeader.json": [64746, 4746],
        "./ModalTitle.json": [48534, 8534],
        "./Nav.json": [34993, 4993],
        "./NavDropdown.json": [38383, 8383],
        "./NavItem.json": [16045, 6045],
        "./NavLink.json": [5400, 5400],
        "./Navbar.json": [79283, 9283],
        "./NavbarBrand.json": [17453, 7453],
        "./NavbarCollapse.json": [44275, 4275],
        "./NavbarOffcanvas.json": [53859, 3859],
        "./NavbarText.json": [98355, 8355],
        "./NavbarToggle.json": [20692, 5330],
        "./Offcanvas.json": [77251, 7251],
        "./OffcanvasBody.json": [96426, 6426],
        "./OffcanvasHeader.json": [10865, 865],
        "./OffcanvasTitle.json": [73804, 3804],
        "./OffcanvasToggling.json": [68778, 8778],
        "./Overlay.json": [53751, 3751],
        "./OverlayTrigger.json": [18225, 8225],
        "./PageItem.json": [60951, 951],
        "./Pagination.json": [61827, 1827],
        "./Placeholder.json": [28794, 8794],
        "./PlaceholderButton.json": [17778, 7778],
        "./Popover.json": [67073, 7073],
        "./PopoverBody.json": [55566, 5566],
        "./PopoverHeader.json": [60363, 363],
        "./ProgressBar.json": [26610, 6610],
        "./Ratio.json": [93103, 3103],
        "./Row.json": [23821, 3821],
        "./Spinner.json": [56329, 6329],
        "./SplitButton.json": [16897, 6897],
        "./Stack.json": [57844, 7844],
        "./Switch.json": [21737, 1737],
        "./TabContainer.json": [29596, 9596],
        "./TabContent.json": [91375, 1375],
        "./TabPane.json": [36012, 7622],
        "./Table.json": [93716, 3716],
        "./Tabs.json": [85058, 5058],
        "./ThemeProvider.json": [97792, 7792],
        "./Toast.json": [4006, 4006],
        "./ToastBody.json": [41271, 1271],
        "./ToastContainer.json": [18896, 8896],
        "./ToastFade.json": [62281, 2281],
        "./ToastHeader.json": [17537, 7537],
        "./ToggleButton.json": [78796, 8796],
        "./ToggleButtonGroup.json": [53710, 3710],
        "./Tooltip.json": [80321, 321],
        "./TransitionWrapper.json": [74334, 4334],
        "./plugin-route-context-module-100.json": [38981, 8981],
        "./renderProgressBar.json": [52667, 2667],
        "./renderTab.json": [77332, 7332],
      };
      function s(e) {
        if (!t.o(o, e))
          return Promise.resolve().then(() => {
            var n = new Error("Cannot find module '" + e + "'");
            throw ((n.code = "MODULE_NOT_FOUND"), n);
          });
        var n = o[e],
          s = n[0];
        return t.e(n[1]).then(() => t.t(s, 19));
      }
      (s.keys = () => Object.keys(o)), (s.id = 2801), (e.exports = s);
    },
    51425: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => v });
      var o = t(60042),
        s = t.n(o),
        r = t(67294),
        a = t(23615),
        i = t.n(a),
        l = t(86191),
        c = t(96837),
        d = t(4708),
        u = t(80338),
        p = t(41075),
        f = t(91767),
        m = t(33285),
        b = t(12752),
        x = t(85893);
      const g = {
          bsPrefix: i().string,
          variant: i().string,
          dismissible: i().bool,
          show: i().bool,
          onClose: i().func,
          closeLabel: i().string,
          closeVariant: i().oneOf(["white"]),
          transition: i().oneOfType([i().bool, l.nm]),
        },
        h = r.forwardRef((e, n) => {
          const {
              bsPrefix: t,
              show: o = !0,
              closeLabel: r = "Close alert",
              closeVariant: a,
              className: i,
              children: l,
              variant: p = "primary",
              onClose: f,
              dismissible: g,
              transition: h = m.Z,
              ...v
            } = (0, c.Ch)(e, { show: "onClose" }),
            y = (0, u.vE)(t, "alert"),
            j = (0, d.Z)((e) => {
              f && f(!1, e);
            }),
            N = !0 === h ? m.Z : h,
            C = (0, x.jsxs)("div", {
              role: "alert",
              ...(N ? void 0 : v),
              ref: n,
              className: s()(i, y, p && `${y}-${p}`, g && `${y}-dismissible`),
              children: [
                g &&
                  (0, x.jsx)(b.Z, { onClick: j, "aria-label": r, variant: a }),
                l,
              ],
            });
          return N
            ? (0, x.jsx)(N, {
                unmountOnExit: !0,
                ...v,
                ref: void 0,
                in: o,
                children: C,
              })
            : o
            ? C
            : null;
        });
      (h.displayName = "Alert"), (h.propTypes = g);
      const v = Object.assign(h, { Link: f.Z, Heading: p.Z });
    },
    41075: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => u });
      var o = t(67294),
        s = t(60042),
        r = t.n(s),
        a = t(80338),
        i = t(54305),
        l = t(85893);
      const c = (0, i.Z)("h4");
      c.displayName = "DivStyledAsH4";
      const d = o.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = c, ...i } = e;
        return (
          (o = (0, a.vE)(o, "alert-heading")),
          (0, l.jsx)(s, { ref: n, className: r()(t, o), ...i })
        );
      });
      d.displayName = "AlertHeading";
      const u = d;
    },
    91767: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => d });
      var o = t(67294),
        s = t(60042),
        r = t.n(s),
        a = t(53950),
        i = t(80338),
        l = t(85893);
      const c = o.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = a.Z, ...c } = e;
        return (
          (o = (0, i.vE)(o, "alert-link")),
          (0, l.jsx)(s, { ref: n, className: r()(t, o), ...c })
        );
      });
      c.displayName = "AlertLink";
      const d = c;
    },
    12752: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => u });
      var o = t(23615),
        s = t.n(o),
        r = t(67294),
        a = t(60042),
        i = t.n(a),
        l = t(85893);
      const c = {
          "aria-label": s().string,
          onClick: s().func,
          variant: s().oneOf(["white"]),
        },
        d = r.forwardRef((e, n) => {
          let { className: t, variant: o, "aria-label": s = "Close", ...r } = e;
          return (0, l.jsx)("button", {
            ref: n,
            type: "button",
            className: i()("btn-close", o && `btn-close-${o}`, t),
            "aria-label": s,
            ...r,
          });
        });
      (d.displayName = "CloseButton"), (d.propTypes = c);
      const u = d;
    },
    33285: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => x });
      var o = t(60042),
        s = t.n(o),
        r = t(23615),
        a = t.n(r),
        i = t(67294),
        l = t(99116),
        c = t(72381),
        d = t(95802),
        u = t(23264),
        p = t(85893);
      const f = {
          in: a().bool,
          mountOnEnter: a().bool,
          unmountOnExit: a().bool,
          appear: a().bool,
          timeout: a().number,
          onEnter: a().func,
          onEntering: a().func,
          onEntered: a().func,
          onExit: a().func,
          onExiting: a().func,
          onExited: a().func,
          children: a().element.isRequired,
          transitionClasses: a().object,
        },
        m = { [l.d0]: "show", [l.cn]: "show" },
        b = i.forwardRef((e, n) => {
          let {
            className: t,
            children: o,
            transitionClasses: r = {},
            onEnter: a,
            ...l
          } = e;
          const f = {
              in: !1,
              timeout: 300,
              mountOnEnter: !1,
              unmountOnExit: !1,
              appear: !1,
              ...l,
            },
            b = (0, i.useCallback)(
              (e, n) => {
                (0, d.Z)(e), a?.(e, n);
              },
              [a]
            );
          return (0, p.jsx)(u.Z, {
            ref: n,
            addEndListener: c.Z,
            ...f,
            onEnter: b,
            childRef: o.ref,
            children: (e, n) =>
              i.cloneElement(o, {
                ...n,
                className: s()("fade", t, o.props.className, m[e], r[e]),
              }),
          });
        });
      (b.propTypes = f), (b.displayName = "Fade");
      const x = b;
    },
    89542: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => p });
      var o = t(60042),
        s = t.n(o),
        r = t(67294),
        a = t(23615),
        i = t.n(a),
        l = t(80338),
        c = t(85893);
      const d = {
          bsPrefix: i().string,
          striped: i().oneOfType([i().bool, i().string]),
          bordered: i().bool,
          borderless: i().bool,
          hover: i().bool,
          size: i().string,
          variant: i().string,
          responsive: i().oneOfType([i().bool, i().string]),
        },
        u = r.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            striped: r,
            bordered: a,
            borderless: i,
            hover: d,
            size: u,
            variant: p,
            responsive: f,
            ...m
          } = e;
          const b = (0, l.vE)(t, "table"),
            x = s()(
              o,
              b,
              p && `${b}-${p}`,
              u && `${b}-${u}`,
              r && `${b}-${"string" == typeof r ? `striped-${r}` : "striped"}`,
              a && `${b}-bordered`,
              i && `${b}-borderless`,
              d && `${b}-hover`
            ),
            g = (0, c.jsx)("table", { ...m, className: x, ref: n });
          if (f) {
            let e = `${b}-responsive`;
            return (
              "string" == typeof f && (e = `${e}-${f}`),
              (0, c.jsx)("div", { className: e, children: g })
            );
          }
          return g;
        });
      u.propTypes = d;
      const p = u;
    },
    80338: (e, n, t) => {
      "use strict";
      t.d(n, {
        Hz: () => i,
        SC: () => x,
        ZP: () => g,
        cs: () => l,
        pi: () => m,
        vE: () => f,
        zG: () => b,
      });
      var o = t(23615),
        s = t.n(o),
        r = t(67294),
        a = t(85893);
      const i = ["xxl", "xl", "lg", "md", "sm", "xs"],
        l = "xs",
        c = r.createContext({ prefixes: {}, breakpoints: i, minBreakpoint: l }),
        { Consumer: d, Provider: u } = c;
      function p(e) {
        let {
          prefixes: n = {},
          breakpoints: t = i,
          minBreakpoint: o = l,
          dir: s,
          children: c,
        } = e;
        const d = (0, r.useMemo)(
          () => ({
            prefixes: { ...n },
            breakpoints: t,
            minBreakpoint: o,
            dir: s,
          }),
          [n, t, o, s]
        );
        return (0, a.jsx)(u, { value: d, children: c });
      }
      function f(e, n) {
        const { prefixes: t } = (0, r.useContext)(c);
        return e || t[n] || n;
      }
      function m() {
        const { breakpoints: e } = (0, r.useContext)(c);
        return e;
      }
      function b() {
        const { minBreakpoint: e } = (0, r.useContext)(c);
        return e;
      }
      function x() {
        const { dir: e } = (0, r.useContext)(c);
        return "rtl" === e;
      }
      p.propTypes = {
        prefixes: s().object,
        breakpoints: s().arrayOf(s().string),
        minBreakpoint: s().string,
        dir: s().string,
      };
      const g = p;
    },
    23264: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => l });
      var o = t(67294),
        s = t(99116),
        r = t(59809),
        a = t(63745),
        i = t(85893);
      const l = o.forwardRef((e, n) => {
        let {
          onEnter: t,
          onEntering: l,
          onEntered: c,
          onExit: d,
          onExiting: u,
          onExited: p,
          addEndListener: f,
          children: m,
          childRef: b,
          ...x
        } = e;
        const g = (0, o.useRef)(null),
          h = (0, r.Z)(g, b),
          v = (e) => {
            h((0, a.Z)(e));
          },
          y = (e) => (n) => {
            e && g.current && e(g.current, n);
          },
          j = (0, o.useCallback)(y(t), [t]),
          N = (0, o.useCallback)(y(l), [l]),
          C = (0, o.useCallback)(y(c), [c]),
          E = (0, o.useCallback)(y(d), [d]),
          w = (0, o.useCallback)(y(u), [u]),
          T = (0, o.useCallback)(y(p), [p]),
          P = (0, o.useCallback)(y(f), [f]);
        return (0, i.jsx)(s.ZP, {
          ref: n,
          ...x,
          onEnter: j,
          onEntered: C,
          onEntering: N,
          onExit: E,
          onExited: T,
          onExiting: w,
          addEndListener: P,
          nodeRef: g,
          children:
            "function" == typeof m
              ? (e, n) => m(e, { ...n, ref: v })
              : o.cloneElement(m, { ref: v }),
        });
      });
    },
    54305: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => i });
      var o = t(67294),
        s = t(60042),
        r = t.n(s),
        a = t(85893);
      const i = (e) =>
        o.forwardRef((n, t) =>
          (0, a.jsx)("div", { ...n, ref: t, className: r()(n.className, e) })
        );
    },
    63745: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => s });
      var o = t(73935);
      function s(e) {
        return e && "setState" in e ? o.findDOMNode(e) : e ?? null;
      }
    },
    72381: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => a });
      var o = t(2739),
        s = t(95056);
      function r(e, n) {
        const t = (0, o.Z)(e, n) || "",
          s = -1 === t.indexOf("ms") ? 1e3 : 1;
        return parseFloat(t) * s;
      }
      function a(e, n) {
        const t = r(e, "transitionDuration"),
          o = r(e, "transitionDelay"),
          a = (0, s.Z)(
            e,
            (t) => {
              t.target === e && (a(), n(t));
            },
            t + o
          );
      }
    },
    95802: (e, n, t) => {
      "use strict";
      function o(e) {
        e.offsetHeight;
      }
      t.d(n, { Z: () => o });
    },
    11572: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => r });
      var o = t(67294),
        s = t(85893);
      const r = (e) => {
        const n = (0, o.useRef)();
        return (0, s.jsx)("div", { ref: n, ...e });
      };
    },
    49129: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => s });
      var o = t(28084);
      function s() {
        return (0, o.eZ)("bootstrap-metadata-plugin");
      }
    },
    69130: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => u });
      var o = t(67294),
        s = t(51425),
        r = t(95999);
      const a = {
        admonition: "admonition_WoCw",
        admonitionHeading: "admonitionHeading_TMsN",
        admonitionIcon: "admonitionIcon_Ibzs",
        admonitionContent: "admonitionContent_vXIg",
      };
      var i = t(85893);
      const l = {
          note: {
            infimaClassName: "secondary",
            iconComponent: function () {
              return (0, i.jsx)("svg", {
                viewBox: "0 0 14 16",
                children: (0, i.jsx)("path", {
                  fillRule: "evenodd",
                  d: "M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z",
                }),
              });
            },
            label: (0, i.jsx)(r.Z, {
              id: "theme.admonition.note",
              description:
                "The default label used for the Note admonition (:::note)",
              children: "Note",
            }),
          },
          tip: {
            infimaClassName: "success",
            iconComponent: function () {
              return (0, i.jsx)("svg", {
                viewBox: "0 0 12 16",
                children: (0, i.jsx)("path", {
                  fillRule: "evenodd",
                  d: "M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z",
                }),
              });
            },
            label: (0, i.jsx)(r.Z, {
              id: "theme.admonition.tip",
              description:
                "The default label used for the Tip admonition (:::tip)",
              children: "Tip",
            }),
          },
          danger: {
            infimaClassName: "danger",
            iconComponent: function () {
              return (0, i.jsx)("svg", {
                viewBox: "0 0 12 16",
                children: (0, i.jsx)("path", {
                  fillRule: "evenodd",
                  d: "M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z",
                }),
              });
            },
            label: (0, i.jsx)(r.Z, {
              id: "theme.admonition.danger",
              description:
                "The default label used for the Danger admonition (:::danger)",
              children: "Danger",
            }),
          },
          info: {
            infimaClassName: "info",
            iconComponent: function () {
              return (0, i.jsx)("svg", {
                viewBox: "0 0 14 16",
                children: (0, i.jsx)("path", {
                  fillRule: "evenodd",
                  d: "M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z",
                }),
              });
            },
            label: (0, i.jsx)(r.Z, {
              id: "theme.admonition.info",
              description:
                "The default label used for the Info admonition (:::info)",
              children: "Info",
            }),
          },
          caution: {
            infimaClassName: "warning",
            iconComponent: function () {
              return (0, i.jsx)("svg", {
                viewBox: "0 0 16 16",
                children: (0, i.jsx)("path", {
                  fillRule: "evenodd",
                  d: "M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z",
                }),
              });
            },
            label: (0, i.jsx)(r.Z, {
              id: "theme.admonition.caution",
              description:
                "The default label used for the Caution admonition (:::caution)",
              children: "Caution",
            }),
          },
        },
        c = {
          secondary: "note",
          important: "info",
          success: "tip",
          warning: "danger",
        };
      function d(e) {
        const { mdxAdmonitionTitle: n, rest: t } = (function (e) {
          const n = o.Children.toArray(e),
            t = n.find(
              (e) =>
                o.isValidElement(e) && "mdxAdmonitionTitle" === e.props?.mdxType
            ),
            s = (0, i.jsx)(i.Fragment, { children: n.filter((e) => e !== t) });
          return { mdxAdmonitionTitle: t, rest: s };
        })(e.children);
        return { ...e, title: e.title ?? n, children: t };
      }
      function u(e) {
        const { children: n, type: t, title: o, icon: r } = d(e),
          u = (function (e) {
            const n = c[e] ?? e,
              t = l[n];
            return (
              t ||
              (console.warn(
                `No admonition config found for admonition type "${n}". Using Info as fallback.`
              ),
              l.info)
            );
          })(t),
          p = o ?? u.label,
          { iconComponent: f } = u,
          m = r ?? (0, i.jsx)(f, {});
        let b;
        switch (t) {
          case "caution":
            b = "warning";
            break;
          case "danger":
            b = "danger";
            break;
          case "info":
            b = "info";
            break;
          case "note":
            b = "secondary";
            break;
          case "tip":
            b = "success";
        }
        return (0, i.jsxs)(s.Z, {
          variant: b,
          children: [
            (0, i.jsxs)(s.Z.Heading, {
              children: [
                (0, i.jsx)("span", {
                  className: a.admonitionIcon,
                  children: m,
                }),
                p,
              ],
            }),
            (0, i.jsx)("div", { className: a.admonitionContent, children: n }),
          ],
        });
      }
    },
    27236: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => i });
      t(67294);
      var o = t(6425),
        s = t(85893);
      const r = /^.*\b(import|export)\b.*$/gim;
      function a(e) {
        return e.replace(r, "");
      }
      function i(e) {
        return (0, s.jsx)(s.Fragment, {
          children: (0, s.jsx)(o.Z, { ...e, transformCode: a }),
        });
      }
    },
    908: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => k });
      var o = t(34626),
        s = t(67294),
        r = t(85893);
      var a = t(27236),
        i = t(49129);
      const l = () => {
        const { bootstrapCssHash: e, bootstrapVersion: n } = (0, i.Z)();
        return (0, r.jsx)(a.Z, {
          language: "html",
          children: `<link\n  rel="stylesheet"\n  href="https://cdn.jsdelivr.net/npm/bootstrap@${n}/dist/css/bootstrap.min.css"\n  integrity="${e}"\n  crossorigin="anonymous"\n/>\n`,
        });
      };
      var c = t(33692);
      const d = function (e) {
        let { path: n, children: t } = e;
        const { bootstrapDocsUrl: o } = (0, i.Z)();
        return (0, r.jsx)(c.Z, { to: `${o}${n}`, children: t });
      };
      var u = t(6425),
        p = t(35576),
        f = t(35742),
        m = t(66279),
        b = t(93394),
        x = t(11925),
        g = t(65471),
        h = t(98231),
        v = t(27390),
        y = t(91470);
      const j = {
          overrides: {
            head: f.Z,
            code: m.Z,
            a: b.Z,
            pre: x.Z,
            details: g.Z,
            ul: v.Z,
            img: y.Z,
            h1: (e) => (0, r.jsx)(h.Z, { as: "h1", ...e }),
            h2: (e) => (0, r.jsx)(h.Z, { as: "h2", ...e }),
            h3: (e) => (0, r.jsx)(h.Z, { as: "h3", ...e }),
            h4: (e) => (0, r.jsx)(h.Z, { as: "h4", ...e }),
            h5: (e) => (0, r.jsx)(h.Z, { as: "h5", ...e }),
            h6: (e) => (0, r.jsx)(h.Z, { as: "h6", ...e }),
          },
        },
        N = (e) => {
          let { children: n, ...t } = e;
          return n ? (0, r.jsx)(p.ZP, { options: j, ...t, children: n }) : null;
        };
      var C = t(89542);
      const E = {
          bsPrefix:
            "Change the underlying component CSS base class name and modifier class names prefix. **This is an escape hatch** for working with heavily customized bootstrap css.",
          variant: "Component visual or contextual style variants.",
          size: "Component size variations.",
          as: "You can use a custom element type for this component.",
          eventKey:
            "A unique identifier for the Component, the `eventKey` makes it distinguishable from others in a set. Similar to React's `key` prop, in that it only needs to be unique amongst the Components siblings, not globally. ",
        },
        w = (e) => {
          let { propName: n, prop: t } = e;
          const o = t.doclets.controllable,
            s = "func" === t.type?.name;
          return (0, r.jsx)("div", {
            className: "mb-2",
            children: (0, r.jsx)("small", {
              children: (0, r.jsx)("em", {
                className: "text-info-emphasis",
                children: s
                  ? (0, r.jsxs)("span", {
                      children: [
                        "controls ",
                        (0, r.jsx)("code", { children: o }),
                      ],
                    })
                  : (0, r.jsxs)("span", {
                      children: [
                        "controlled by: ",
                        (0, r.jsx)("code", { children: o }),
                        ", initial prop:",
                        " ",
                        (0, r.jsx)("code", {
                          children: `default${
                            ((a = n), a[0].toUpperCase() + a.slice(1))
                          }`,
                        }),
                      ],
                    }),
              }),
            }),
          });
          var a;
        };
      function T(e) {
        const n = [];
        return (
          e.forEach((e, t) => {
            t > 0 && n.push((0, r.jsx)("span", { children: " | " }, `${t}c`)),
              n.push((0, r.jsx)("code", { children: e }, t));
          }),
          (0, r.jsx)(r.Fragment, { children: n })
        );
      }
      const P = (e) => {
        let { prop: n } = e;
        if (n.doclets.type)
          return T(
            n.doclets.type
              .trim()
              .replace(/^\{/, "")
              .replace(/\}$/, "")
              .replace(/^\(/, "")
              .replace(/\)$/, "")
              .split("|")
          );
        const { type: t } = n,
          { name: o, value: s } = t || {};
        return "union" === o
          ? T(s.map((e) => e.name))
          : "enum" === o
          ? T(s.map((e) => e.value))
          : o ?? null;
      };
      const O = (e) => {
          let { name: n } = e;
          const o = (function (e) {
            const [n, o] = (0, s.useState)(null);
            return (
              (0, s.useEffect)(() => {
                t(2801)(`./${e}.json`)
                  .then((e) => {
                    o(e.default);
                  })
                  .catch(console.error);
              }, [e]),
              n
            );
          })(n);
          return o
            ? (0, r.jsxs)(r.Fragment, {
                children: [
                  (0, r.jsx)(u.Z, {
                    language: "jsx",
                    children: `import ${n} from 'react-bootstrap/${n}'`,
                  }),
                  o.description &&
                    (0, r.jsx)("div", {
                      className: "my-3",
                      children: (0, r.jsx)(N, { children: o.description }),
                    }),
                  (0, r.jsxs)(C.Z, {
                    children: [
                      (0, r.jsx)("thead", {
                        children: (0, r.jsxs)("tr", {
                          children: [
                            (0, r.jsx)("th", { children: "Name" }),
                            (0, r.jsx)("th", { children: "Type" }),
                            (0, r.jsx)("th", { children: "Default" }),
                            (0, r.jsx)("th", { children: "Description" }),
                          ],
                        }),
                      }),
                      (0, r.jsx)("tbody", {
                        children: Object.entries(o.props).map((e) => {
                          let [n, t] = e;
                          if (t.doclets.private) return null;
                          const o = t.doclets.default ?? t.defaultValue?.value,
                            s = !!t.doclets.deprecated;
                          return (0, r.jsxs)(
                            "tr",
                            {
                              children: [
                                (0, r.jsxs)("td", {
                                  className: "font-monospace",
                                  children: [
                                    n,
                                    " ",
                                    t.required &&
                                      (0, r.jsx)("sup", {
                                        className: "text-danger",
                                        children: "Required",
                                      }),
                                  ],
                                }),
                                (0, r.jsx)("td", {
                                  className: "font-monospace",
                                  children: (0, r.jsx)("div", {
                                    children: (0, r.jsx)(P, { prop: t }),
                                  }),
                                }),
                                (0, r.jsx)("td", {
                                  children:
                                    o && (0, r.jsx)("code", { children: o }),
                                }),
                                (0, r.jsxs)("td", {
                                  children: [
                                    s &&
                                      (0, r.jsx)("div", {
                                        className: "mb-1",
                                        children: (0, r.jsx)("strong", {
                                          className: "text-danger",
                                          children: "Deprecated",
                                        }),
                                      }),
                                    t.doclets.controllable &&
                                      (0, r.jsx)(w, { propName: n, prop: t }),
                                    (0, r.jsx)(N, {
                                      children: t.description || E[n],
                                    }),
                                  ],
                                }),
                              ],
                            },
                            n
                          );
                        }),
                      }),
                    ],
                  }),
                ],
              })
            : null;
        },
        k = {
          ...o.Z,
          AriaAbbr: function () {
            return (0, r.jsx)("abbr", {
              title: "Accessible Rich Internet Applications",
              children: "ARIA",
            });
          },
          CodeBlock: a.Z,
          CssCodeBlock: l,
          DocLink: d,
          PropsTable: O,
        };
    },
    57496: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => i });
      t(67294);
      var o = t(45042),
        s = t(65130),
        r = t(11572),
        a = t(85893);
      function i(e) {
        const { frontMatter: n } = (0, s.k)();
        return (0, a.jsxs)(a.Fragment, {
          children: [
            n.description &&
              (0, a.jsx)("p", { className: "lead", children: n.description }),
            (0, a.jsx)(r.Z, { className: "my-4" }),
            (0, a.jsx)(o.Z, { ...e }),
          ],
        });
      }
    },
    11660: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => T });
      var o = t(67294),
        s = t(90512),
        r = t(72389),
        a = t(61313),
        i = t(95999),
        l = t(52263),
        c = t(91262),
        d = t(66412),
        u = t(9779),
        p = t(60930),
        f = t(99585),
        m = t(45351),
        b = t(85893);
      const x = (e) => {
          let { className: n } = e;
          const s = (0, o.useRef)(),
            [r, i] = (0, o.useState)(null),
            l = (0, o.useContext)(a.L2);
          return (
            (0, o.useEffect)(() => {
              t.e(2775)
                .then(t.t.bind(t, 42775, 23))
                .then((e) => {
                  let { default: n } = e;
                  n.addTheme("gray", {
                    bg: "#373940",
                    fg: "#999",
                    fontweight: "normal",
                  }),
                    i(n);
                });
            }, []),
            (0, f.Z)(() => {
              r && r.run({ theme: "gray", images: (0, p.Z)(s.current, "img") });
            }, [r, l.element]),
            (0, m.Z)(s.current, { childList: !0, subtree: !0 }, (e) => {
              e.forEach((e) => {
                r &&
                  e.addedNodes.length > 0 &&
                  r.run({ theme: "gray", images: (0, p.Z)(s.current, "img") });
              });
            }),
            (0, b.jsx)("div", {
              ref: s,
              children: (0, b.jsx)(a.i5, { className: n }),
            })
          );
        },
        g = {
          playgroundContainer: "playgroundContainer_TGbA",
          playgroundHeader: "playgroundHeader_qwyd",
          playgroundEditor: "playgroundEditor_PvJ1",
          playgroundPreview: "playgroundPreview_bb8I",
          editorToolbar: "editorToolbar_ACgP",
          editorInfoMessage: "editorInfoMessage_ISBk",
          buttonGroup: "buttonGroup_wSGZ",
        },
        h = (e) =>
          (0, b.jsx)("div", {
            className: (0, s.Z)("alert alert-info p-2", g.editorInfoMessage),
            ...e,
          });
      h.displayName = "EditorInfoMessage";
      const v = h;
      function y(e) {
        let { children: n } = e;
        return (0, b.jsx)("div", {
          className: (0, s.Z)(g.playgroundHeader),
          children: n,
        });
      }
      function j() {
        return (0, b.jsx)("div", { children: "Loading..." });
      }
      function N(e) {
        let { className: n } = e;
        return (0, b.jsxs)(b.Fragment, {
          children: [
            (0, b.jsx)(y, {
              children: (0, b.jsx)(i.Z, {
                id: "theme.Playground.result",
                description: "The result label of the live codeblocks",
                children: "Result",
              }),
            }),
            (0, b.jsx)("div", {
              className: g.playgroundPreview,
              children: (0, b.jsx)(c.Z, {
                fallback: (0, b.jsx)(j, {}),
                children: () =>
                  (0, b.jsxs)(b.Fragment, {
                    children: [
                      (0, b.jsx)(x, { className: n }),
                      (0, b.jsx)(a.IF, {}),
                    ],
                  }),
              }),
            }),
          ],
        });
      }
      let C = 0;
      function E() {
        const { code: e } = (0, o.useContext)(a.L2),
          n = (0, r.Z)(),
          [t, i] = (0, o.useState)(!1),
          [l, c] = (0, o.useState)(!1),
          [d, p] = (0, o.useState)(!1),
          f = (0, o.useRef)(!1),
          m = (0, o.useRef)(null);
        null === m.current && (m.current = "described-by-" + ++C);
        const x = m.current,
          h = (0, o.useCallback)(
            (e) => {
              l
                ? "Tab" !== e.key &&
                  "Shift" !== e.key &&
                  ("Enter" === e.key && e.preventDefault(), c(!1))
                : "Escape" === e.key && c(!0);
            },
            [l]
          ),
          y = (0, o.useCallback)(() => {
            i(!0), c(!f.current), p(!f.current);
          }, []),
          j = (0, o.useCallback)(() => {
            i(!1);
          }, []),
          N = (0, o.useCallback)(() => {
            (f.current = !0),
              window.setTimeout(() => {
                f.current = !1;
              });
          }, []),
          E = { ignoreTabKey: l },
          w = d || (t && !l);
        return (0, b.jsxs)("div", {
          className: "position-relative",
          children: [
            (0, b.jsx)(
              a.uz,
              {
                className: g.playgroundEditor,
                onFocus: y,
                onBlur: j,
                onKeyDown: h,
                onMouseDown: N,
                "aria-describedby": w ? x : null,
                ...E,
              },
              String(n)
            ),
            (0, b.jsxs)("div", {
              className: (0, s.Z)(g.editorToolbar),
              children: [
                w &&
                  (0, b.jsx)(v, {
                    id: x,
                    "aria-live": "polite",
                    children: l
                      ? (0, b.jsxs)(b.Fragment, {
                          children: [
                            "Press ",
                            (0, b.jsx)("kbd", { children: "enter" }),
                            " or type a key to enable tab-to-indent",
                          ],
                        })
                      : (0, b.jsxs)(b.Fragment, {
                          children: [
                            "Press ",
                            (0, b.jsx)("kbd", { children: "esc" }),
                            " to disable tab trapping",
                          ],
                        }),
                  }),
                (0, b.jsx)("div", {
                  className: g.buttonGroup,
                  children: (0, b.jsx)(u.Z, { code: e }),
                }),
              ],
            }),
          ],
        });
      }
      function w() {
        return (0, b.jsxs)(b.Fragment, {
          children: [
            (0, b.jsx)(y, {
              children: (0, b.jsx)(i.Z, {
                id: "theme.Playground.liveEditor",
                description: "The live editor label of the live codeblocks",
                children: "Live Editor",
              }),
            }),
            (0, b.jsx)(E, {}),
          ],
        });
      }
      function T(e) {
        let { children: n, transformCode: t, previewClassName: o, ...r } = e;
        const {
            siteConfig: { themeConfig: i },
          } = (0, l.Z)(),
          {
            liveCodeBlock: { playgroundPosition: c },
          } = i,
          u = (0, d.p)(),
          p = r.metastring?.includes("noInline") ?? !1;
        return (0, b.jsx)("div", {
          className: g.playgroundContainer,
          children: (0, b.jsx)(a.nu, {
            code: n.replace(/\n$/, ""),
            noInline: p,
            transformCode: t ?? ((e) => `${e};`),
            theme: u,
            ...r,
            children:
              "top" === c
                ? (0, b.jsxs)(b.Fragment, {
                    children: [
                      (0, b.jsx)(N, { className: (0, s.Z)("bs-example", o) }),
                      (0, b.jsx)(w, {}),
                    ],
                  })
                : (0, b.jsxs)(b.Fragment, {
                    children: [
                      (0, b.jsx)(w, {}),
                      (0, b.jsx)(N, { className: (0, s.Z)("bs-example", o) }),
                    ],
                  }),
          }),
        });
      }
    },
    65358: (e, n, t) => {
      "use strict";
      t.d(n, { Z: () => mi });
      var o = {};
      t.r(o),
        t.d(o, {
          Accordion: () => U,
          AccordionBody: () => S,
          AccordionButton: () => L,
          AccordionCollapse: () => R,
          AccordionContext: () => P,
          AccordionHeader: () => z,
          AccordionItem: () => G,
          Alert: () => W.Z,
          AlertHeading: () => X.Z,
          AlertLink: () => Y.Z,
          Anchor: () => Q,
          Badge: () => te,
          Breadcrumb: () => le,
          BreadcrumbItem: () => re,
          Button: () => pe,
          ButtonGroup: () => be,
          ButtonToolbar: () => he,
          Card: () => Ve,
          CardBody: () => ye,
          CardFooter: () => Ne,
          CardGroup: () => Ue,
          CardHeader: () => Pe,
          CardImg: () => Re,
          CardImgOverlay: () => Ze,
          CardLink: () => Fe,
          CardSubtitle: () => Ae,
          CardText: () => He,
          CardTitle: () => Ke,
          Carousel: () => cn,
          CarouselCaption: () => en,
          CarouselItem: () => on,
          CloseButton: () => dn.Z,
          Col: () => gn,
          Collapse: () => E,
          Container: () => yn,
          Dropdown: () => rt,
          DropdownButton: () => lt,
          DropdownDivider: () => wn,
          DropdownHeader: () => Pn,
          DropdownItem: () => $n,
          DropdownItemText: () => In,
          DropdownMenu: () => Yn,
          DropdownToggle: () => tt,
          Fade: () => ct.Z,
          Figure: () => ht,
          FigureCaption: () => xt,
          FigureImage: () => mt,
          FloatingLabel: () => to,
          Form: () => ro,
          FormCheck: () => $t,
          FormControl: () => Ft,
          FormFloating: () => Bt,
          FormGroup: () => Lt,
          FormLabel: () => zt,
          FormSelect: () => Ut,
          FormText: () => Yt,
          Image: () => pt,
          InputGroup: () => uo,
          ListGroup: () => yo,
          ListGroupItem: () => go,
          Modal: () => ls,
          ModalBody: () => zo,
          ModalDialog: () => Vo,
          ModalFooter: () => Uo,
          ModalHeader: () => es,
          ModalTitle: () => os,
          Nav: () => hs,
          NavDropdown: () => nr,
          NavItem: () => ps,
          NavLink: () => bs,
          Navbar: () => Js,
          NavbarBrand: () => js,
          NavbarCollapse: () => Es,
          NavbarOffcanvas: () => qs,
          NavbarText: () => Ws,
          NavbarToggle: () => Ps,
          Offcanvas: () => Gs,
          OffcanvasBody: () => Rs,
          OffcanvasHeader: () => Ms,
          OffcanvasTitle: () => Hs,
          OffcanvasToggling: () => Fs,
          Overlay: () => yr,
          OverlayTrigger: () => Tr,
          PageItem: () => kr,
          Pagination: () => Ar,
          Placeholder: () => Gr,
          PlaceholderButton: () => zr,
          Popover: () => fr,
          PopoverBody: () => lr,
          PopoverHeader: () => ar,
          ProgressBar: () => Yr,
          Ratio: () => ea,
          Row: () => ra,
          SSRProvider: () => pa,
          Spinner: () => la,
          SplitButton: () => ua,
          Stack: () => ga,
          Tab: () => Ia,
          TabContainer: () => Ca,
          TabContent: () => wa,
          TabPane: () => Ra,
          Table: () => Fa.Z,
          Tabs: () => La,
          ThemeProvider: () => u.ZP,
          Toast: () => Ya,
          ToastBody: () => Ua,
          ToastContainer: () => ni,
          ToastHeader: () => Va,
          ToggleButton: () => ri,
          ToggleButtonGroup: () => li,
          Tooltip: () => xr,
          useAccordionButton: () => M,
        });
      var s = t(67294),
        r = t.t(s, 2),
        a = t(60042),
        i = t.n(a),
        l = t(23615),
        c = t.n(l),
        d = t(96837),
        u = t(80338),
        p = t(2739),
        f = t(99116),
        m = t(72381);
      const b = function () {
        for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++)
          n[t] = arguments[t];
        return n
          .filter((e) => null != e)
          .reduce((e, n) => {
            if ("function" != typeof n)
              throw new Error(
                "Invalid Argument Type, must only provide functions, undefined, or null."
              );
            return null === e
              ? n
              : function () {
                  for (
                    var t = arguments.length, o = new Array(t), s = 0;
                    s < t;
                    s++
                  )
                    o[s] = arguments[s];
                  e.apply(this, o), n.apply(this, o);
                };
          }, null);
      };
      var x = t(95802),
        g = t(23264),
        h = t(85893);
      const v = {
        height: ["marginTop", "marginBottom"],
        width: ["marginLeft", "marginRight"],
      };
      function y(e, n) {
        const t = n[`offset${e[0].toUpperCase()}${e.slice(1)}`],
          o = v[e];
        return (
          t + parseInt((0, p.Z)(n, o[0]), 10) + parseInt((0, p.Z)(n, o[1]), 10)
        );
      }
      const j = {
          [f.Wj]: "collapse",
          [f.Ix]: "collapsing",
          [f.d0]: "collapsing",
          [f.cn]: "collapse show",
        },
        N = {
          in: c().bool,
          mountOnEnter: c().bool,
          unmountOnExit: c().bool,
          appear: c().bool,
          timeout: c().number,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
          dimension: c().oneOfType([c().oneOf(["height", "width"]), c().func]),
          getDimensionValue: c().func,
          role: c().string,
          children: c().element.isRequired,
        },
        C = s.forwardRef((e, n) => {
          let {
            onEnter: t,
            onEntering: o,
            onEntered: r,
            onExit: a,
            onExiting: l,
            className: c,
            children: d,
            dimension: u = "height",
            in: p = !1,
            timeout: f = 300,
            mountOnEnter: v = !1,
            unmountOnExit: N = !1,
            appear: C = !1,
            getDimensionValue: E = y,
            ...w
          } = e;
          const T = "function" == typeof u ? u() : u,
            P = (0, s.useMemo)(
              () =>
                b((e) => {
                  e.style[T] = "0";
                }, t),
              [T, t]
            ),
            O = (0, s.useMemo)(
              () =>
                b((e) => {
                  const n = `scroll${T[0].toUpperCase()}${T.slice(1)}`;
                  e.style[T] = `${e[n]}px`;
                }, o),
              [T, o]
            ),
            k = (0, s.useMemo)(
              () =>
                b((e) => {
                  e.style[T] = null;
                }, r),
              [T, r]
            ),
            R = (0, s.useMemo)(
              () =>
                b((e) => {
                  (e.style[T] = `${E(T, e)}px`), (0, x.Z)(e);
                }, a),
              [a, E, T]
            ),
            $ = (0, s.useMemo)(
              () =>
                b((e) => {
                  e.style[T] = null;
                }, l),
              [T, l]
            );
          return (0, h.jsx)(g.Z, {
            ref: n,
            addEndListener: m.Z,
            ...w,
            "aria-expanded": w.role ? p : null,
            onEnter: P,
            onEntering: O,
            onEntered: k,
            onExit: R,
            onExiting: $,
            childRef: d.ref,
            in: p,
            timeout: f,
            mountOnEnter: v,
            unmountOnExit: N,
            appear: C,
            children: (e, n) =>
              s.cloneElement(d, {
                ...n,
                className: i()(
                  c,
                  d.props.className,
                  j[e],
                  "width" === T && "collapse-horizontal"
                ),
              }),
          });
        });
      C.propTypes = N;
      const E = C;
      function w(e, n) {
        return Array.isArray(e) ? e.includes(n) : e === n;
      }
      const T = s.createContext({});
      T.displayName = "AccordionContext";
      const P = T,
        O = {
          as: c().elementType,
          eventKey: c().string.isRequired,
          children: c().element.isRequired,
        },
        k = s.forwardRef((e, n) => {
          let {
            as: t = "div",
            bsPrefix: o,
            className: r,
            children: a,
            eventKey: l,
            ...c
          } = e;
          const { activeEventKey: d } = (0, s.useContext)(P);
          return (
            (o = (0, u.vE)(o, "accordion-collapse")),
            (0, h.jsx)(E, {
              ref: n,
              in: w(d, l),
              ...c,
              className: i()(r, o),
              children: (0, h.jsx)(t, { children: s.Children.only(a) }),
            })
          );
        });
      (k.propTypes = O), (k.displayName = "AccordionCollapse");
      const R = k,
        $ = s.createContext({ eventKey: "" });
      $.displayName = "AccordionItemContext";
      const Z = $,
        I = {
          as: c().elementType,
          bsPrefix: c().string,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
        },
        F = s.forwardRef((e, n) => {
          let {
            as: t = "div",
            bsPrefix: o,
            className: r,
            onEnter: a,
            onEntering: l,
            onEntered: c,
            onExit: d,
            onExiting: p,
            onExited: f,
            ...m
          } = e;
          o = (0, u.vE)(o, "accordion-body");
          const { eventKey: b } = (0, s.useContext)(Z);
          return (0, h.jsx)(R, {
            eventKey: b,
            onEnter: a,
            onEntering: l,
            onEntered: c,
            onExit: d,
            onExiting: p,
            onExited: f,
            children: (0, h.jsx)(t, { ref: n, ...m, className: i()(r, o) }),
          });
        });
      (F.propTypes = I), (F.displayName = "AccordionBody");
      const S = F,
        B = { as: c().elementType, bsPrefix: c().string, onClick: c().func };
      function M(e, n) {
        const {
          activeEventKey: t,
          onSelect: o,
          alwaysOpen: r,
        } = (0, s.useContext)(P);
        return (s) => {
          let a = e === t ? null : e;
          r &&
            (a = Array.isArray(t)
              ? t.includes(e)
                ? t.filter((n) => n !== e)
                : [...t, e]
              : [e]),
            o?.(a, s),
            n?.(s);
        };
      }
      const A = s.forwardRef((e, n) => {
        let {
          as: t = "button",
          bsPrefix: o,
          className: r,
          onClick: a,
          ...l
        } = e;
        o = (0, u.vE)(o, "accordion-button");
        const { eventKey: c } = (0, s.useContext)(Z),
          d = M(c, a),
          { activeEventKey: p } = (0, s.useContext)(P);
        return (
          "button" === t && (l.type = "button"),
          (0, h.jsx)(t, {
            ref: n,
            onClick: d,
            ...l,
            "aria-expanded": Array.isArray(p) ? p.includes(c) : c === p,
            className: i()(r, o, !w(p, c) && "collapsed"),
          })
        );
      });
      (A.propTypes = B), (A.displayName = "AccordionButton");
      const L = A,
        H = { as: c().elementType, bsPrefix: c().string, onClick: c().func },
        D = s.forwardRef((e, n) => {
          let {
            as: t = "h2",
            bsPrefix: o,
            className: s,
            children: r,
            onClick: a,
            ...l
          } = e;
          return (
            (o = (0, u.vE)(o, "accordion-header")),
            (0, h.jsx)(t, {
              ref: n,
              ...l,
              className: i()(s, o),
              children: (0, h.jsx)(L, { onClick: a, children: r }),
            })
          );
        });
      (D.propTypes = H), (D.displayName = "AccordionHeader");
      const z = D,
        K = {
          as: c().elementType,
          bsPrefix: c().string,
          eventKey: c().string.isRequired,
        },
        _ = s.forwardRef((e, n) => {
          let {
            as: t = "div",
            bsPrefix: o,
            className: r,
            eventKey: a,
            ...l
          } = e;
          o = (0, u.vE)(o, "accordion-item");
          const c = (0, s.useMemo)(() => ({ eventKey: a }), [a]);
          return (0, h.jsx)(Z.Provider, {
            value: c,
            children: (0, h.jsx)(t, { ref: n, ...l, className: i()(r, o) }),
          });
        });
      (_.propTypes = K), (_.displayName = "AccordionItem");
      const G = _,
        V = {
          as: c().elementType,
          bsPrefix: c().string,
          activeKey: c().oneOfType([c().string, c().array]),
          defaultActiveKey: c().oneOfType([c().string, c().array]),
          onSelect: c().func,
          flush: c().bool,
          alwaysOpen: c().bool,
        },
        q = s.forwardRef((e, n) => {
          const {
              as: t = "div",
              activeKey: o,
              bsPrefix: r,
              className: a,
              onSelect: l,
              flush: c,
              alwaysOpen: p,
              ...f
            } = (0, d.Ch)(e, { activeKey: "onSelect" }),
            m = (0, u.vE)(r, "accordion"),
            b = (0, s.useMemo)(
              () => ({ activeEventKey: o, onSelect: l, alwaysOpen: p }),
              [o, l, p]
            );
          return (0, h.jsx)(P.Provider, {
            value: b,
            children: (0, h.jsx)(t, {
              ref: n,
              ...f,
              className: i()(a, m, c && `${m}-flush`),
            }),
          });
        });
      (q.displayName = "Accordion"), (q.propTypes = V);
      const U = Object.assign(q, {
        Button: L,
        Collapse: R,
        Item: G,
        Header: z,
        Body: S,
      });
      var W = t(51425),
        X = t(41075),
        Y = t(91767),
        J = t(53950);
      const Q = J.Z,
        ee = {
          bsPrefix: c().string,
          bg: c().string,
          pill: c().bool,
          text: c().string,
          as: c().elementType,
        },
        ne = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            bg: o = "primary",
            pill: s = !1,
            text: r,
            className: a,
            as: l = "span",
            ...c
          } = e;
          const d = (0, u.vE)(t, "badge");
          return (0, h.jsx)(l, {
            ref: n,
            ...c,
            className: i()(
              a,
              d,
              s && "rounded-pill",
              r && `text-${r}`,
              o && `bg-${o}`
            ),
          });
        });
      (ne.displayName = "Badge"), (ne.propTypes = ee);
      const te = ne,
        oe = {
          bsPrefix: c().string,
          active: c().bool,
          href: c().string,
          linkAs: c().elementType,
          title: c().node,
          target: c().string,
          linkProps: c().object,
          as: c().elementType,
        },
        se = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            active: o = !1,
            children: s,
            className: r,
            as: a = "li",
            linkAs: l = J.Z,
            linkProps: c = {},
            href: d,
            title: p,
            target: f,
            ...m
          } = e;
          const b = (0, u.vE)(t, "breadcrumb-item");
          return (0, h.jsx)(a, {
            ref: n,
            ...m,
            className: i()(b, r, { active: o }),
            "aria-current": o ? "page" : void 0,
            children: o
              ? s
              : (0, h.jsx)(l, {
                  ...c,
                  href: d,
                  title: p,
                  target: f,
                  children: s,
                }),
          });
        });
      (se.displayName = "BreadcrumbItem"), (se.propTypes = oe);
      const re = se,
        ae = {
          bsPrefix: c().string,
          label: c().string,
          listProps: c().object,
          as: c().elementType,
        },
        ie = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            listProps: s = {},
            children: r,
            label: a = "breadcrumb",
            as: l = "nav",
            ...c
          } = e;
          const d = (0, u.vE)(t, "breadcrumb");
          return (0, h.jsx)(l, {
            "aria-label": a,
            className: o,
            ref: n,
            ...c,
            children: (0, h.jsx)("ol", {
              ...s,
              className: i()(d, s?.className),
              children: r,
            }),
          });
        });
      (ie.displayName = "Breadcrumb"), (ie.propTypes = ae);
      const le = Object.assign(ie, { Item: re });
      var ce = t(6120);
      const de = {
          bsPrefix: c().string,
          variant: c().string,
          onClick: c().func,
          size: c().string,
          active: c().bool,
          disabled: c().bool,
          href: c().string,
          type: c().oneOf(["button", "reset", "submit", null]),
          as: c().elementType,
        },
        ue = s.forwardRef((e, n) => {
          let {
            as: t,
            bsPrefix: o,
            variant: s = "primary",
            size: r,
            active: a = !1,
            disabled: l = !1,
            className: c,
            ...d
          } = e;
          const p = (0, u.vE)(o, "btn"),
            [f, { tagName: m }] = (0, ce.FT)({ tagName: t, disabled: l, ...d }),
            b = m;
          return (0, h.jsx)(b, {
            ...f,
            ...d,
            ref: n,
            disabled: l,
            className: i()(
              c,
              p,
              a && "active",
              s && `${p}-${s}`,
              r && `${p}-${r}`,
              d.href && l && "disabled"
            ),
          });
        });
      (ue.displayName = "Button"), (ue.propTypes = de);
      const pe = ue,
        fe = {
          bsPrefix: c().string,
          size: c().string,
          vertical: c().bool,
          role: c().string,
          as: c().elementType,
        },
        me = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            size: o,
            vertical: s = !1,
            className: r,
            role: a = "group",
            as: l = "div",
            ...c
          } = e;
          const d = (0, u.vE)(t, "btn-group");
          let p = d;
          return (
            s && (p = `${d}-vertical`),
            (0, h.jsx)(l, {
              ...c,
              ref: n,
              role: a,
              className: i()(r, p, o && `${d}-${o}`),
            })
          );
        });
      (me.displayName = "ButtonGroup"), (me.propTypes = fe);
      const be = me,
        xe = { bsPrefix: c().string, role: c().string },
        ge = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, role: s = "toolbar", ...r } = e;
          const a = (0, u.vE)(t, "btn-toolbar");
          return (0, h.jsx)("div", {
            ...r,
            ref: n,
            className: i()(o, a),
            role: s,
          });
        });
      (ge.displayName = "ButtonToolbar"), (ge.propTypes = xe);
      const he = ge,
        ve = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-body")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      ve.displayName = "CardBody";
      const ye = ve,
        je = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-footer")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      je.displayName = "CardFooter";
      const Ne = je,
        Ce = s.createContext(null);
      Ce.displayName = "CardHeaderContext";
      const Ee = Ce,
        we = { bsPrefix: c().string, as: c().elementType },
        Te = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, as: r = "div", ...a } = e;
          const l = (0, u.vE)(t, "card-header"),
            c = (0, s.useMemo)(() => ({ cardHeaderBsPrefix: l }), [l]);
          return (0, h.jsx)(Ee.Provider, {
            value: c,
            children: (0, h.jsx)(r, { ref: n, ...a, className: i()(o, l) }),
          });
        });
      (Te.displayName = "CardHeader"), (Te.propTypes = we);
      const Pe = Te,
        Oe = {
          bsPrefix: c().string,
          variant: c().oneOf(["top", "bottom"]),
          as: c().elementType,
        },
        ke = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            variant: s,
            as: r = "img",
            ...a
          } = e;
          const l = (0, u.vE)(t, "card-img");
          return (0, h.jsx)(r, {
            ref: n,
            className: i()(s ? `${l}-${s}` : l, o),
            ...a,
          });
        });
      (ke.displayName = "CardImg"), (ke.propTypes = Oe);
      const Re = ke,
        $e = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-img-overlay")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      $e.displayName = "CardImgOverlay";
      const Ze = $e,
        Ie = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "a", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-link")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Ie.displayName = "CardLink";
      const Fe = Ie;
      var Se = t(54305);
      const Be = (0, Se.Z)("h6"),
        Me = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = Be, ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-subtitle")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Me.displayName = "CardSubtitle";
      const Ae = Me,
        Le = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "p", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-text")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Le.displayName = "CardText";
      const He = Le,
        De = (0, Se.Z)("h5"),
        ze = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = De, ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-title")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      ze.displayName = "CardTitle";
      const Ke = ze,
        _e = {
          bsPrefix: c().string,
          bg: c().string,
          text: c().string,
          border: c().string,
          body: c().bool,
          as: c().elementType,
        },
        Ge = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            bg: s,
            text: r,
            border: a,
            body: l = !1,
            children: c,
            as: d = "div",
            ...p
          } = e;
          const f = (0, u.vE)(t, "card");
          return (0, h.jsx)(d, {
            ref: n,
            ...p,
            className: i()(
              o,
              f,
              s && `bg-${s}`,
              r && `text-${r}`,
              a && `border-${a}`
            ),
            children: l ? (0, h.jsx)(ye, { children: c }) : c,
          });
        });
      (Ge.displayName = "Card"), (Ge.propTypes = _e);
      const Ve = Object.assign(Ge, {
          Img: Re,
          Title: Ke,
          Subtitle: Ae,
          Body: ye,
          Link: Fe,
          Text: He,
          Header: Pe,
          Footer: Ne,
          ImgOverlay: Ze,
        }),
        qe = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "card-group")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      qe.displayName = "CardGroup";
      const Ue = qe;
      var We = t(4708),
        Xe = t(70388),
        Ye = t(6153),
        Je = t(59634);
      const Qe = s.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
        return (
          (o = (0, u.vE)(o, "carousel-caption")),
          (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
        );
      });
      Qe.displayName = "CarouselCaption";
      const en = Qe,
        nn = {
          as: c().elementType,
          bsPrefix: c().string,
          interval: c().number,
        },
        tn = s.forwardRef((e, n) => {
          let { as: t = "div", bsPrefix: o, className: s, ...r } = e;
          const a = i()(s, (0, u.vE)(o, "carousel-item"));
          return (0, h.jsx)(t, { ref: n, ...r, className: a });
        });
      (tn.displayName = "CarouselItem"), (tn.propTypes = nn);
      const on = tn;
      function sn(e, n) {
        let t = 0;
        return s.Children.map(e, (e) => (s.isValidElement(e) ? n(e, t++) : e));
      }
      function rn(e, n) {
        let t = 0;
        s.Children.forEach(e, (e) => {
          s.isValidElement(e) && n(e, t++);
        });
      }
      const an = {
        bsPrefix: c().string,
        as: c().elementType,
        slide: c().bool,
        fade: c().bool,
        controls: c().bool,
        indicators: c().bool,
        indicatorLabels: c().array,
        activeIndex: c().number,
        onSelect: c().func,
        onSlide: c().func,
        onSlid: c().func,
        interval: c().oneOfType([c().number, c().oneOf([null])]),
        keyboard: c().bool,
        pause: c().oneOf(["hover", !1]),
        wrap: c().bool,
        touch: c().bool,
        prevIcon: c().node,
        prevLabel: c().string,
        nextIcon: c().node,
        nextLabel: c().string,
        variant: c().oneOf(["dark"]),
      };
      const ln = s.forwardRef((e, n) => {
        let { defaultActiveIndex: t = 0, ...o } = e;
        const {
            as: r = "div",
            bsPrefix: a,
            slide: l = !0,
            fade: c = !1,
            controls: p = !0,
            indicators: f = !0,
            indicatorLabels: b = [],
            activeIndex: v,
            onSelect: y,
            onSlide: j,
            onSlid: N,
            interval: C = 5e3,
            keyboard: E = !0,
            onKeyDown: w,
            pause: T = "hover",
            onMouseOver: P,
            onMouseOut: O,
            wrap: k = !0,
            touch: R = !0,
            onTouchStart: $,
            onTouchMove: Z,
            onTouchEnd: I,
            prevIcon: F = (0, h.jsx)("span", {
              "aria-hidden": "true",
              className: "carousel-control-prev-icon",
            }),
            prevLabel: S = "Previous",
            nextIcon: B = (0, h.jsx)("span", {
              "aria-hidden": "true",
              className: "carousel-control-next-icon",
            }),
            nextLabel: M = "Next",
            variant: A,
            className: L,
            children: H,
            ...D
          } = (0, d.Ch)(
            { defaultActiveIndex: t, ...o },
            { activeIndex: "onSelect" }
          ),
          z = (0, u.vE)(a, "carousel"),
          K = (0, u.SC)(),
          _ = (0, s.useRef)(null),
          [G, V] = (0, s.useState)("next"),
          [q, U] = (0, s.useState)(!1),
          [W, X] = (0, s.useState)(!1),
          [Y, Q] = (0, s.useState)(v || 0);
        (0, s.useEffect)(() => {
          W ||
            v === Y ||
            (_.current ? V(_.current) : V((v || 0) > Y ? "next" : "prev"),
            l && X(!0),
            Q(v || 0));
        }, [v, W, Y, l]),
          (0, s.useEffect)(() => {
            _.current && (_.current = null);
          });
        let ee,
          ne = 0;
        rn(H, (e, n) => {
          ++ne, n === v && (ee = e.props.interval);
        });
        const te = (0, Ye.Z)(ee),
          oe = (0, s.useCallback)(
            (e) => {
              if (W) return;
              let n = Y - 1;
              if (n < 0) {
                if (!k) return;
                n = ne - 1;
              }
              (_.current = "prev"), y?.(n, e);
            },
            [W, Y, y, k, ne]
          ),
          se = (0, We.Z)((e) => {
            if (W) return;
            let n = Y + 1;
            if (n >= ne) {
              if (!k) return;
              n = 0;
            }
            (_.current = "next"), y?.(n, e);
          }),
          re = (0, s.useRef)();
        (0, s.useImperativeHandle)(n, () => ({
          element: re.current,
          prev: oe,
          next: se,
        }));
        const ae = (0, We.Z)(() => {
            !document.hidden &&
              (function (e) {
                if (!(e && e.style && e.parentNode && e.parentNode.style))
                  return !1;
                const n = getComputedStyle(e);
                return (
                  "none" !== n.display &&
                  "hidden" !== n.visibility &&
                  "none" !== getComputedStyle(e.parentNode).display
                );
              })(re.current) &&
              (K ? oe() : se());
          }),
          ie = "next" === G ? "start" : "end";
        (0, Xe.Z)(() => {
          l || (j?.(Y, ie), N?.(Y, ie));
        }, [Y]);
        const le = `${z}-item-${G}`,
          ce = `${z}-item-${ie}`,
          de = (0, s.useCallback)(
            (e) => {
              (0, x.Z)(e), j?.(Y, ie);
            },
            [j, Y, ie]
          ),
          ue = (0, s.useCallback)(() => {
            X(!1), N?.(Y, ie);
          }, [N, Y, ie]),
          pe = (0, s.useCallback)(
            (e) => {
              if (E && !/input|textarea/i.test(e.target.tagName))
                switch (e.key) {
                  case "ArrowLeft":
                    return e.preventDefault(), void (K ? se(e) : oe(e));
                  case "ArrowRight":
                    return e.preventDefault(), void (K ? oe(e) : se(e));
                }
              w?.(e);
            },
            [E, w, oe, se, K]
          ),
          fe = (0, s.useCallback)(
            (e) => {
              "hover" === T && U(!0), P?.(e);
            },
            [T, P]
          ),
          me = (0, s.useCallback)(
            (e) => {
              U(!1), O?.(e);
            },
            [O]
          ),
          be = (0, s.useRef)(0),
          xe = (0, s.useRef)(0),
          ge = (0, Je.Z)(),
          he = (0, s.useCallback)(
            (e) => {
              (be.current = e.touches[0].clientX),
                (xe.current = 0),
                "hover" === T && U(!0),
                $?.(e);
            },
            [T, $]
          ),
          ve = (0, s.useCallback)(
            (e) => {
              e.touches && e.touches.length > 1
                ? (xe.current = 0)
                : (xe.current = e.touches[0].clientX - be.current),
                Z?.(e);
            },
            [Z]
          ),
          ye = (0, s.useCallback)(
            (e) => {
              if (R) {
                const n = xe.current;
                Math.abs(n) > 40 && (n > 0 ? oe(e) : se(e));
              }
              "hover" === T &&
                ge.set(() => {
                  U(!1);
                }, C || void 0),
                I?.(e);
            },
            [R, T, oe, se, ge, C, I]
          ),
          je = null != C && !q && !W,
          Ne = (0, s.useRef)();
        (0, s.useEffect)(() => {
          if (!je) return;
          const e = K ? oe : se;
          return (
            (Ne.current = window.setInterval(
              document.visibilityState ? ae : e,
              te.current ?? C ?? void 0
            )),
            () => {
              null !== Ne.current && clearInterval(Ne.current);
            }
          );
        }, [je, oe, se, te, C, ae, K]);
        const Ce = (0, s.useMemo)(
          () =>
            f &&
            Array.from({ length: ne }, (e, n) => (e) => {
              y?.(n, e);
            }),
          [f, ne, y]
        );
        return (0, h.jsxs)(r, {
          ref: re,
          ...D,
          onKeyDown: pe,
          onMouseOver: fe,
          onMouseOut: me,
          onTouchStart: he,
          onTouchMove: ve,
          onTouchEnd: ye,
          className: i()(
            L,
            z,
            l && "slide",
            c && `${z}-fade`,
            A && `${z}-${A}`
          ),
          children: [
            f &&
              (0, h.jsx)("div", {
                className: `${z}-indicators`,
                children: sn(H, (e, n) =>
                  (0, h.jsx)(
                    "button",
                    {
                      type: "button",
                      "data-bs-target": "",
                      "aria-label": b?.length ? b[n] : `Slide ${n + 1}`,
                      className: n === Y ? "active" : void 0,
                      onClick: Ce ? Ce[n] : void 0,
                      "aria-current": n === Y,
                    },
                    n
                  )
                ),
              }),
            (0, h.jsx)("div", {
              className: `${z}-inner`,
              children: sn(H, (e, n) => {
                const t = n === Y;
                return l
                  ? (0, h.jsx)(g.Z, {
                      in: t,
                      onEnter: t ? de : void 0,
                      onEntered: t ? ue : void 0,
                      addEndListener: m.Z,
                      children: (n, o) =>
                        s.cloneElement(e, {
                          ...o,
                          className: i()(
                            e.props.className,
                            t && "entered" !== n && le,
                            ("entered" === n || "exiting" === n) && "active",
                            ("entering" === n || "exiting" === n) && ce
                          ),
                        }),
                    })
                  : s.cloneElement(e, {
                      className: i()(e.props.className, t && "active"),
                    });
              }),
            }),
            p &&
              (0, h.jsxs)(h.Fragment, {
                children: [
                  (k || 0 !== v) &&
                    (0, h.jsxs)(J.Z, {
                      className: `${z}-control-prev`,
                      onClick: oe,
                      children: [
                        F,
                        S &&
                          (0, h.jsx)("span", {
                            className: "visually-hidden",
                            children: S,
                          }),
                      ],
                    }),
                  (k || v !== ne - 1) &&
                    (0, h.jsxs)(J.Z, {
                      className: `${z}-control-next`,
                      onClick: se,
                      children: [
                        B,
                        M &&
                          (0, h.jsx)("span", {
                            className: "visually-hidden",
                            children: M,
                          }),
                      ],
                    }),
                ],
              }),
          ],
        });
      });
      (ln.displayName = "Carousel"), (ln.propTypes = an);
      const cn = Object.assign(ln, { Caption: en, Item: on });
      var dn = t(12752);
      const un = c().oneOfType([
          c().bool,
          c().number,
          c().string,
          c().oneOf(["auto"]),
        ]),
        pn = c().oneOfType([c().number, c().string]),
        fn = c().oneOfType([
          un,
          c().shape({ size: un, order: pn, offset: pn }),
        ]),
        mn = {
          bsPrefix: c().string,
          as: c().elementType,
          xs: fn,
          sm: fn,
          md: fn,
          lg: fn,
          xl: fn,
          xxl: fn,
        };
      function bn(e) {
        let { as: n, bsPrefix: t, className: o, ...s } = e;
        t = (0, u.vE)(t, "col");
        const r = (0, u.pi)(),
          a = (0, u.zG)(),
          l = [],
          c = [];
        return (
          r.forEach((e) => {
            const n = s[e];
            let o, r, i;
            delete s[e],
              "object" == typeof n && null != n
                ? ({ span: o, offset: r, order: i } = n)
                : (o = n);
            const d = e !== a ? `-${e}` : "";
            o && l.push(!0 === o ? `${t}${d}` : `${t}${d}-${o}`),
              null != i && c.push(`order${d}-${i}`),
              null != r && c.push(`offset${d}-${r}`);
          }),
          [
            { ...s, className: i()(o, ...l, ...c) },
            { as: n, bsPrefix: t, spans: l },
          ]
        );
      }
      const xn = s.forwardRef((e, n) => {
        const [
          { className: t, ...o },
          { as: s = "div", bsPrefix: r, spans: a },
        ] = bn(e);
        return (0, h.jsx)(s, {
          ...o,
          ref: n,
          className: i()(t, !a.length && r),
        });
      });
      (xn.displayName = "Col"), (xn.propTypes = mn);
      const gn = xn,
        hn = {
          bsPrefix: c().string,
          fluid: c().oneOfType([c().bool, c().string]),
          as: c().elementType,
        },
        vn = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            fluid: o = !1,
            as: s = "div",
            className: r,
            ...a
          } = e;
          const l = (0, u.vE)(t, "container"),
            c = "string" == typeof o ? `-${o}` : "-fluid";
          return (0, h.jsx)(s, {
            ref: n,
            ...a,
            className: i()(r, o ? `${l}${c}` : l),
          });
        });
      (vn.displayName = "Container"), (vn.propTypes = hn);
      const yn = vn;
      var jn = t(29508);
      const Nn = s.createContext({});
      Nn.displayName = "DropdownContext";
      const Cn = Nn,
        En = s.forwardRef((e, n) => {
          let {
            className: t,
            bsPrefix: o,
            as: s = "hr",
            role: r = "separator",
            ...a
          } = e;
          return (
            (o = (0, u.vE)(o, "dropdown-divider")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), role: r, ...a })
          );
        });
      En.displayName = "DropdownDivider";
      const wn = En,
        Tn = s.forwardRef((e, n) => {
          let {
            className: t,
            bsPrefix: o,
            as: s = "div",
            role: r = "heading",
            ...a
          } = e;
          return (
            (o = (0, u.vE)(o, "dropdown-header")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), role: r, ...a })
          );
        });
      Tn.displayName = "DropdownHeader";
      const Pn = Tn;
      var On = t(35684);
      const kn = {
          bsPrefix: c().string,
          active: c().bool,
          disabled: c().bool,
          eventKey: c().oneOfType([c().string, c().number]),
          href: c().string,
          onClick: c().func,
          as: c().elementType,
        },
        Rn = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            eventKey: s,
            disabled: r = !1,
            onClick: a,
            active: l,
            as: c = J.Z,
            ...d
          } = e;
          const p = (0, u.vE)(t, "dropdown-item"),
            [f, m] = (0, On.F)({
              key: s,
              href: d.href,
              disabled: r,
              onClick: a,
              active: l,
            });
          return (0, h.jsx)(c, {
            ...d,
            ...f,
            ref: n,
            className: i()(o, p, m.isActive && "active", r && "disabled"),
          });
        });
      (Rn.displayName = "DropdownItem"), (Rn.propTypes = kn);
      const $n = Rn,
        Zn = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "span", ...r } = e;
          return (
            (o = (0, u.vE)(o, "dropdown-item-text")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Zn.displayName = "DropdownItemText";
      const In = Zn;
      var Fn = t(78200),
        Sn = t(35300),
        Bn = t(59809),
        Mn = t(91895),
        An = t.n(Mn);
      const Ln = s.createContext(null);
      Ln.displayName = "InputGroupContext";
      const Hn = Ln,
        Dn = s.createContext(null);
      Dn.displayName = "NavbarContext";
      const zn = Dn;
      var Kn = t(3996),
        _n = t.n(Kn);
      function Gn(e, n) {
        return e;
      }
      const Vn = c().oneOf(["start", "end"]),
        qn = c().oneOfType([
          Vn,
          c().shape({ sm: Vn }),
          c().shape({ md: Vn }),
          c().shape({ lg: Vn }),
          c().shape({ xl: Vn }),
          c().shape({ xxl: Vn }),
          c().object,
        ]),
        Un = {
          bsPrefix: c().string,
          show: c().bool,
          renderOnMount: c().bool,
          flip: c().bool,
          align: qn,
          rootCloseEvent: c().oneOf(["click", "mousedown"]),
          as: c().elementType,
          popperConfig: c().object,
          variant: c().string,
        };
      function Wn(e, n, t) {
        let o = e
          ? t
            ? "bottom-start"
            : "bottom-end"
          : t
          ? "bottom-end"
          : "bottom-start";
        return (
          "up" === n
            ? (o = e
                ? t
                  ? "top-start"
                  : "top-end"
                : t
                ? "top-end"
                : "top-start")
            : "end" === n
            ? (o = e
                ? t
                  ? "left-end"
                  : "right-end"
                : t
                ? "left-start"
                : "right-start")
            : "start" === n
            ? (o = e
                ? t
                  ? "right-end"
                  : "left-end"
                : t
                ? "right-start"
                : "left-start")
            : "down-centered" === n
            ? (o = "bottom")
            : "up-centered" === n && (o = "top"),
          o
        );
      }
      const Xn = s.forwardRef((e, n) => {
        let {
            bsPrefix: t,
            className: o,
            align: r,
            rootCloseEvent: a,
            flip: l = !0,
            show: c,
            renderOnMount: d,
            as: p = "div",
            popperConfig: f,
            variant: m,
            ...b
          } = e,
          x = !1;
        const g = (0, s.useContext)(zn),
          v = (0, u.vE)(t, "dropdown-menu"),
          { align: y, drop: j, isRTL: N } = (0, s.useContext)(Cn);
        r = r || y;
        const C = (0, s.useContext)(Hn),
          E = [];
        if (r)
          if ("object" == typeof r) {
            const e = Object.keys(r);
            if (
              (An()(
                1 === e.length,
                "There should only be 1 breakpoint when passing an object to `align`"
              ),
              e.length)
            ) {
              const n = e[0],
                t = r[n];
              (x = "start" === t), E.push(`${v}-${n}-${t}`);
            }
          } else "end" === r && (x = !0);
        const w = Wn(x, j, N),
          [T, { hasShown: P, popper: O, show: k, toggle: R }] = (0, Fn.d)({
            flip: l,
            rootCloseEvent: a,
            show: c,
            usePopper: !g && 0 === E.length,
            offset: [0, 2],
            popperConfig: f,
            placement: w,
          });
        if (
          ((T.ref = (0, Bn.Z)(Gn(n), T.ref)),
          (0, Sn.Z)(() => {
            k && O?.update();
          }, [k]),
          !P && !d && !C)
        )
          return null;
        "string" != typeof p &&
          ((T.show = k), (T.close = () => R?.(!1)), (T.align = r));
        let $ = b.style;
        return (
          O?.placement &&
            (($ = { ...b.style, ...T.style }),
            (b["x-placement"] = O.placement)),
          (0, h.jsx)(p, {
            ...b,
            ...T,
            style: $,
            ...((E.length || g) && { "data-bs-popper": "static" }),
            className: i()(
              o,
              v,
              k && "show",
              x && `${v}-end`,
              m && `${v}-${m}`,
              ...E
            ),
          })
        );
      });
      (Xn.displayName = "DropdownMenu"), (Xn.propTypes = Un);
      const Yn = Xn;
      var Jn = t(65779),
        Qn = t(81410);
      const et = {
          bsPrefix: c().string,
          id: c().string,
          split: c().bool,
          as: c().elementType,
          childBsPrefix: c().string,
        },
        nt = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            split: o,
            className: r,
            childBsPrefix: a,
            as: l = pe,
            ...c
          } = e;
          const d = (0, u.vE)(t, "dropdown-toggle"),
            p = (0, s.useContext)(Jn.Z);
          void 0 !== a && (c.bsPrefix = a);
          const [f] = (0, Qn.Jr)();
          return (
            (f.ref = (0, Bn.Z)(f.ref, Gn(n))),
            (0, h.jsx)(l, {
              className: i()(r, d, o && `${d}-split`, p?.show && "show"),
              ...f,
              ...c,
            })
          );
        });
      (nt.displayName = "DropdownToggle"), (nt.propTypes = et);
      const tt = nt,
        ot = {
          bsPrefix: c().string,
          drop: c().oneOf([
            "up",
            "up-centered",
            "start",
            "end",
            "down",
            "down-centered",
          ]),
          as: c().elementType,
          align: qn,
          show: c().bool,
          onToggle: c().func,
          onSelect: c().func,
          focusFirstItemOnShow: c().oneOf([!1, !0, "keyboard"]),
          navbar: c().bool,
          autoClose: c().oneOf([!0, "outside", "inside", !1]),
        },
        st = s.forwardRef((e, n) => {
          const {
              bsPrefix: t,
              drop: o = "down",
              show: r,
              className: a,
              align: l = "start",
              onSelect: c,
              onToggle: p,
              focusFirstItemOnShow: f,
              as: m = "div",
              navbar: b,
              autoClose: x = !0,
              ...g
            } = (0, d.Ch)(e, { show: "onToggle" }),
            v = (0, s.useContext)(Hn),
            y = (0, u.vE)(t, "dropdown"),
            j = (0, u.SC)(),
            N = (0, We.Z)((e, n) => {
              const t =
                n.originalEvent?.target?.classList.contains("dropdown-toggle");
              var o;
              (t && "mousedown" === n.source) ||
                (n.originalEvent.currentTarget !== document ||
                  ("keydown" === n.source &&
                    "Escape" !== n.originalEvent.key) ||
                  (n.source = "rootClose"),
                (o = n.source),
                (!1 === x
                  ? "click" === o
                  : "inside" === x
                  ? "rootClose" !== o
                  : "outside" !== x || "select" !== o) && p?.(e, n));
            }),
            C = Wn("end" === l, o, j),
            E = (0, s.useMemo)(
              () => ({ align: l, drop: o, isRTL: j }),
              [l, o, j]
            ),
            w = {
              down: y,
              "down-centered": `${y}-center`,
              up: "dropup",
              "up-centered": "dropup-center dropup",
              end: "dropend",
              start: "dropstart",
            };
          return (0, h.jsx)(Cn.Provider, {
            value: E,
            children: (0, h.jsx)(jn.Z, {
              placement: C,
              show: r,
              onSelect: c,
              onToggle: N,
              focusFirstItemOnShow: f,
              itemSelector: `.${y}-item:not(.disabled):not(:disabled)`,
              children: v
                ? g.children
                : (0, h.jsx)(m, {
                    ...g,
                    ref: n,
                    className: i()(a, r && "show", w[o]),
                  }),
            }),
          });
        });
      (st.displayName = "Dropdown"), (st.propTypes = ot);
      const rt = Object.assign(st, {
          Toggle: tt,
          Menu: Yn,
          Item: $n,
          ItemText: In,
          Divider: wn,
          Header: Pn,
        }),
        at = {
          id: c().string,
          href: c().string,
          onClick: c().func,
          title: c().node.isRequired,
          disabled: c().bool,
          align: qn,
          menuRole: c().string,
          renderMenuOnMount: c().bool,
          rootCloseEvent: c().string,
          menuVariant: c().oneOf(["dark"]),
          flip: c().bool,
          bsPrefix: c().string,
          variant: c().string,
          size: c().string,
        },
        it = s.forwardRef((e, n) => {
          let {
            title: t,
            children: o,
            bsPrefix: s,
            rootCloseEvent: r,
            variant: a,
            size: i,
            menuRole: l,
            renderMenuOnMount: c,
            disabled: d,
            href: u,
            id: p,
            menuVariant: f,
            flip: m,
            ...b
          } = e;
          return (0, h.jsxs)(rt, {
            ref: n,
            ...b,
            children: [
              (0, h.jsx)(tt, {
                id: p,
                href: u,
                size: i,
                variant: a,
                disabled: d,
                childBsPrefix: s,
                children: t,
              }),
              (0, h.jsx)(Yn, {
                role: l,
                renderOnMount: c,
                rootCloseEvent: r,
                variant: f,
                flip: m,
                children: o,
              }),
            ],
          });
        });
      (it.displayName = "DropdownButton"), (it.propTypes = at);
      const lt = it;
      var ct = t(33285);
      const dt = {
          bsPrefix: c().string,
          fluid: c().bool,
          rounded: c().bool,
          roundedCircle: c().bool,
          thumbnail: c().bool,
        },
        ut = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            fluid: s = !1,
            rounded: r = !1,
            roundedCircle: a = !1,
            thumbnail: l = !1,
            ...c
          } = e;
          return (
            (t = (0, u.vE)(t, "img")),
            (0, h.jsx)("img", {
              ref: n,
              ...c,
              className: i()(
                o,
                s && `${t}-fluid`,
                r && "rounded",
                a && "rounded-circle",
                l && `${t}-thumbnail`
              ),
            })
          );
        });
      (ut.displayName = "Image"), (ut.propTypes = dt);
      const pt = ut,
        ft = s.forwardRef((e, n) => {
          let { className: t, fluid: o = !0, ...s } = e;
          return (0, h.jsx)(pt, {
            ref: n,
            ...s,
            fluid: o,
            className: i()(t, "figure-img"),
          });
        });
      (ft.displayName = "FigureImage"), (ft.propTypes = dt);
      const mt = ft,
        bt = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "figcaption", ...r } = e;
          return (
            (o = (0, u.vE)(o, "figure-caption")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      bt.displayName = "FigureCaption";
      const xt = bt,
        gt = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "figure", ...r } = e;
          return (
            (o = (0, u.vE)(o, "figure")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      gt.displayName = "Figure";
      const ht = Object.assign(gt, { Image: mt, Caption: xt }),
        vt = { type: c().string, tooltip: c().bool, as: c().elementType },
        yt = s.forwardRef((e, n) => {
          let {
            as: t = "div",
            className: o,
            type: s = "valid",
            tooltip: r = !1,
            ...a
          } = e;
          return (0, h.jsx)(t, {
            ...a,
            ref: n,
            className: i()(o, `${s}-${r ? "tooltip" : "feedback"}`),
          });
        });
      (yt.displayName = "Feedback"), (yt.propTypes = vt);
      const jt = yt,
        Nt = s.createContext({}),
        Ct = {
          bsPrefix: c().string,
          as: c().elementType,
          id: c().string,
          type: c().oneOf(["radio", "checkbox"]).isRequired,
          isValid: c().bool,
          isInvalid: c().bool,
        },
        Et = s.forwardRef((e, n) => {
          let {
            id: t,
            bsPrefix: o,
            className: r,
            type: a = "checkbox",
            isValid: l = !1,
            isInvalid: c = !1,
            as: d = "input",
            ...p
          } = e;
          const { controlId: f } = (0, s.useContext)(Nt);
          return (
            (o = (0, u.vE)(o, "form-check-input")),
            (0, h.jsx)(d, {
              ...p,
              ref: n,
              type: a,
              id: t || f,
              className: i()(r, o, l && "is-valid", c && "is-invalid"),
            })
          );
        });
      (Et.displayName = "FormCheckInput"), (Et.propTypes = Ct);
      const wt = Et,
        Tt = { bsPrefix: c().string, htmlFor: c().string },
        Pt = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, htmlFor: r, ...a } = e;
          const { controlId: l } = (0, s.useContext)(Nt);
          return (
            (t = (0, u.vE)(t, "form-check-label")),
            (0, h.jsx)("label", {
              ...a,
              ref: n,
              htmlFor: r || l,
              className: i()(o, t),
            })
          );
        });
      (Pt.displayName = "FormCheckLabel"), (Pt.propTypes = Tt);
      const Ot = Pt,
        kt = {
          bsPrefix: c().string,
          bsSwitchPrefix: c().string,
          _ref: c().any,
          as: c().elementType,
          id: c().string,
          children: c().node,
          inline: c().bool,
          reverse: c().bool,
          disabled: c().bool,
          title: c().string,
          label: c().node,
          type: c().oneOf(["radio", "checkbox", "switch"]),
          isValid: c().bool,
          isInvalid: c().bool,
          feedbackTooltip: c().bool,
          feedback: c().node,
          feedbackType: c().oneOf(["valid", "invalid"]),
        },
        Rt = s.forwardRef((e, n) => {
          let {
            id: t,
            bsPrefix: o,
            bsSwitchPrefix: r,
            inline: a = !1,
            reverse: l = !1,
            disabled: c = !1,
            isValid: d = !1,
            isInvalid: p = !1,
            feedbackTooltip: f = !1,
            feedback: m,
            feedbackType: b,
            className: x,
            style: g,
            title: v = "",
            type: y = "checkbox",
            label: j,
            children: N,
            as: C = "input",
            ...E
          } = e;
          (o = (0, u.vE)(o, "form-check")), (r = (0, u.vE)(r, "form-switch"));
          const { controlId: w } = (0, s.useContext)(Nt),
            T = (0, s.useMemo)(() => ({ controlId: t || w }), [w, t]),
            P =
              (!N && null != j && !1 !== j) ||
              (function (e, n) {
                return s.Children.toArray(e).some(
                  (e) => s.isValidElement(e) && e.type === n
                );
              })(N, Ot),
            O = (0, h.jsx)(wt, {
              ...E,
              type: "switch" === y ? "checkbox" : y,
              ref: n,
              isValid: d,
              isInvalid: p,
              disabled: c,
              as: C,
            });
          return (0, h.jsx)(Nt.Provider, {
            value: T,
            children: (0, h.jsx)("div", {
              style: g,
              className: i()(
                x,
                P && o,
                a && `${o}-inline`,
                l && `${o}-reverse`,
                "switch" === y && r
              ),
              children:
                N ||
                (0, h.jsxs)(h.Fragment, {
                  children: [
                    O,
                    P && (0, h.jsx)(Ot, { title: v, children: j }),
                    m && (0, h.jsx)(jt, { type: b, tooltip: f, children: m }),
                  ],
                }),
            }),
          });
        });
      (Rt.displayName = "FormCheck"), (Rt.propTypes = kt);
      const $t = Object.assign(Rt, { Input: wt, Label: Ot }),
        Zt = {
          bsPrefix: c().string,
          _ref: c().any,
          size: c().string,
          htmlSize: c().number,
          as: c().elementType,
          plaintext: c().bool,
          readOnly: c().bool,
          disabled: c().bool,
          value: c().oneOfType([
            c().string,
            c().arrayOf(c().string),
            c().number,
          ]),
          onChange: c().func,
          type: c().string,
          id: c().string,
          isValid: c().bool,
          isInvalid: c().bool,
        },
        It = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            type: o,
            size: r,
            htmlSize: a,
            id: l,
            className: c,
            isValid: d = !1,
            isInvalid: p = !1,
            plaintext: f,
            readOnly: m,
            as: b = "input",
            ...x
          } = e;
          const { controlId: g } = (0, s.useContext)(Nt);
          return (
            (t = (0, u.vE)(t, "form-control")),
            An()(
              null == g || !l,
              "`controlId` is ignored on `<FormControl>` when `id` is specified."
            ),
            (0, h.jsx)(b, {
              ...x,
              type: o,
              size: a,
              ref: n,
              readOnly: m,
              id: l || g,
              className: i()(
                c,
                f ? `${t}-plaintext` : t,
                r && `${t}-${r}`,
                "color" === o && `${t}-color`,
                d && "is-valid",
                p && "is-invalid"
              ),
            })
          );
        });
      (It.displayName = "FormControl"), (It.propTypes = Zt);
      const Ft = Object.assign(It, { Feedback: jt }),
        St = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "form-floating")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      St.displayName = "FormFloating";
      const Bt = St,
        Mt = { as: c().elementType, controlId: c().string, _ref: c().any },
        At = s.forwardRef((e, n) => {
          let { controlId: t, as: o = "div", ...r } = e;
          const a = (0, s.useMemo)(() => ({ controlId: t }), [t]);
          return (0, h.jsx)(Nt.Provider, {
            value: a,
            children: (0, h.jsx)(o, { ...r, ref: n }),
          });
        });
      (At.displayName = "FormGroup"), (At.propTypes = Mt);
      const Lt = At,
        Ht = {
          bsPrefix: c().string,
          htmlFor: c().string,
          column: c().oneOfType([c().bool, c().oneOf(["sm", "lg"])]),
          _ref: c().any,
          visuallyHidden: c().bool,
          as: c().elementType,
        },
        Dt = s.forwardRef((e, n) => {
          let {
            as: t = "label",
            bsPrefix: o,
            column: r = !1,
            visuallyHidden: a = !1,
            className: l,
            htmlFor: c,
            ...d
          } = e;
          const { controlId: p } = (0, s.useContext)(Nt);
          o = (0, u.vE)(o, "form-label");
          let f = "col-form-label";
          "string" == typeof r && (f = `${f} ${f}-${r}`);
          const m = i()(l, o, a && "visually-hidden", r && f);
          return (
            An()(
              null == p || !c,
              "`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified."
            ),
            (c = c || p),
            r
              ? (0, h.jsx)(gn, {
                  ref: n,
                  as: "label",
                  className: m,
                  htmlFor: c,
                  ...d,
                })
              : (0, h.jsx)(t, { ref: n, className: m, htmlFor: c, ...d })
          );
        });
      (Dt.displayName = "FormLabel"), (Dt.propTypes = Ht);
      const zt = Dt,
        Kt = {
          bsPrefix: c().string,
          disabled: c().bool,
          value: c().oneOfType([
            c().string,
            c().arrayOf(c().string.isRequired),
            c().number,
          ]),
          onChange: c().func,
          id: c().string,
        },
        _t = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, id: r, ...a } = e;
          const { controlId: l } = (0, s.useContext)(Nt);
          return (
            (t = (0, u.vE)(t, "form-range")),
            (0, h.jsx)("input", {
              ...a,
              type: "range",
              ref: n,
              className: i()(o, t),
              id: r || l,
            })
          );
        });
      (_t.displayName = "FormRange"), (_t.propTypes = Kt);
      const Gt = _t,
        Vt = {
          bsPrefix: c().string,
          size: c().string,
          htmlSize: c().number,
          disabled: c().bool,
          value: c().oneOfType([
            c().string,
            c().arrayOf(c().string),
            c().number,
          ]),
          onChange: c().func,
          isValid: c().bool,
          isInvalid: c().bool,
        },
        qt = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            size: o,
            htmlSize: r,
            className: a,
            isValid: l = !1,
            isInvalid: c = !1,
            id: d,
            ...p
          } = e;
          const { controlId: f } = (0, s.useContext)(Nt);
          return (
            (t = (0, u.vE)(t, "form-select")),
            (0, h.jsx)("select", {
              ...p,
              size: r,
              ref: n,
              className: i()(
                a,
                t,
                o && `${t}-${o}`,
                l && "is-valid",
                c && "is-invalid"
              ),
              id: d || f,
            })
          );
        });
      (qt.displayName = "FormSelect"), (qt.propTypes = Vt);
      const Ut = qt,
        Wt = {
          bsPrefix: c().string,
          _ref: c().any,
          muted: c().bool,
          as: c().elementType,
        },
        Xt = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            as: s = "small",
            muted: r,
            ...a
          } = e;
          return (
            (t = (0, u.vE)(t, "form-text")),
            (0, h.jsx)(s, {
              ...a,
              ref: n,
              className: i()(o, t, r && "text-muted"),
            })
          );
        });
      (Xt.displayName = "FormText"), (Xt.propTypes = Wt);
      const Yt = Xt,
        Jt = s.forwardRef((e, n) =>
          (0, h.jsx)($t, { ...e, ref: n, type: "switch" })
        );
      Jt.displayName = "Switch";
      const Qt = Object.assign(Jt, { Input: $t.Input, Label: $t.Label }),
        eo = {
          as: c().elementType,
          controlId: c().string,
          label: c().node.isRequired,
        },
        no = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            children: s,
            controlId: r,
            label: a,
            ...l
          } = e;
          return (
            (t = (0, u.vE)(t, "form-floating")),
            (0, h.jsxs)(Lt, {
              ref: n,
              className: i()(o, t),
              controlId: r,
              ...l,
              children: [s, (0, h.jsx)("label", { htmlFor: r, children: a })],
            })
          );
        });
      (no.displayName = "FloatingLabel"), (no.propTypes = eo);
      const to = no,
        oo = { _ref: c().any, validated: c().bool, as: c().elementType },
        so = s.forwardRef((e, n) => {
          let { className: t, validated: o, as: s = "form", ...r } = e;
          return (0, h.jsx)(s, {
            ...r,
            ref: n,
            className: i()(t, o && "was-validated"),
          });
        });
      (so.displayName = "Form"), (so.propTypes = oo);
      const ro = Object.assign(so, {
          Group: Lt,
          Control: Ft,
          Floating: Bt,
          Check: $t,
          Switch: Qt,
          Label: zt,
          Text: Yt,
          Range: Gt,
          Select: Ut,
          FloatingLabel: to,
        }),
        ao = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "span", ...r } = e;
          return (
            (o = (0, u.vE)(o, "input-group-text")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      ao.displayName = "InputGroupText";
      const io = ao,
        lo = {
          bsPrefix: c().string,
          size: c().string,
          hasValidation: c().bool,
          as: c().elementType,
        },
        co = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            size: o,
            hasValidation: r,
            className: a,
            as: l = "div",
            ...c
          } = e;
          t = (0, u.vE)(t, "input-group");
          const d = (0, s.useMemo)(() => ({}), []);
          return (0, h.jsx)(Hn.Provider, {
            value: d,
            children: (0, h.jsx)(l, {
              ref: n,
              ...c,
              className: i()(a, t, o && `${t}-${o}`, r && "has-validation"),
            }),
          });
        });
      (co.propTypes = lo), (co.displayName = "InputGroup");
      const uo = Object.assign(co, {
        Text: io,
        Radio: (e) =>
          (0, h.jsx)(io, { children: (0, h.jsx)(wt, { type: "radio", ...e }) }),
        Checkbox: (e) =>
          (0, h.jsx)(io, {
            children: (0, h.jsx)(wt, { type: "checkbox", ...e }),
          }),
      });
      var po = t(89912),
        fo = t(83691),
        mo = t(97958);
      const bo = {
          bsPrefix: c().string,
          variant: c().string,
          action: c().bool,
          active: c().bool,
          disabled: c().bool,
          eventKey: c().oneOfType([c().string, c().number]),
          onClick: c().func,
          href: c().string,
          as: c().elementType,
        },
        xo = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            active: o,
            disabled: s,
            eventKey: r,
            className: a,
            variant: l,
            action: c,
            as: d,
            ...p
          } = e;
          t = (0, u.vE)(t, "list-group-item");
          const [f, m] = (0, fo.v)({
              key: (0, mo.h)(r, p.href),
              active: o,
              ...p,
            }),
            b = (0, We.Z)((e) => {
              if (s) return e.preventDefault(), void e.stopPropagation();
              f.onClick(e);
            });
          s &&
            void 0 === p.tabIndex &&
            ((p.tabIndex = -1), (p["aria-disabled"] = !0));
          const x = d || (c ? (p.href ? "a" : "button") : "div");
          return (
            An()(
              d || !(!c && p.href),
              "`action=false` and `href` should not be used together."
            ),
            (0, h.jsx)(x, {
              ref: n,
              ...p,
              ...f,
              onClick: b,
              className: i()(
                a,
                t,
                m.isActive && "active",
                s && "disabled",
                l && `${t}-${l}`,
                c && `${t}-action`
              ),
            })
          );
        });
      (xo.propTypes = bo), (xo.displayName = "ListGroupItem");
      const go = xo,
        ho = {
          bsPrefix: c().string,
          variant: c().oneOf(["flush"]),
          horizontal: c().oneOfType([c().bool, c().string]),
          numbered: c().bool,
          as: c().elementType,
        },
        vo = s.forwardRef((e, n) => {
          const {
              className: t,
              bsPrefix: o,
              variant: s,
              horizontal: r,
              numbered: a,
              as: l = "div",
              ...c
            } = (0, d.Ch)(e, { activeKey: "onSelect" }),
            p = (0, u.vE)(o, "list-group");
          let f;
          return (
            r && (f = !0 === r ? "horizontal" : `horizontal-${r}`),
            An()(
              !(r && "flush" === s),
              '`variant="flush"` and `horizontal` should not be used together.'
            ),
            (0, h.jsx)(po.Z, {
              ref: n,
              ...c,
              as: l,
              className: i()(
                t,
                p,
                s && `${p}-${s}`,
                f && `${p}-${f}`,
                a && `${p}-numbered`
              ),
            })
          );
        });
      (vo.propTypes = ho), (vo.displayName = "ListGroup");
      const yo = Object.assign(vo, { Item: go });
      var jo = t(45072),
        No = t(93335),
        Co = t(26783),
        Eo = t(56978),
        wo = t(54830),
        To = t(31818),
        Po = t(58554),
        Oo = t(95056),
        ko = t(51928),
        Ro = t(51689),
        $o = t(47841),
        Zo = t(46455),
        Io = t(31547);
      const Fo = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
        So = ".sticky-top",
        Bo = ".navbar-toggler";
      class Mo extends Io.Z {
        adjustAndStore(e, n, t) {
          const o = n.style[e];
          (n.dataset[e] = o),
            (0, p.Z)(n, { [e]: `${parseFloat((0, p.Z)(n, e)) + t}px` });
        }
        restore(e, n) {
          const t = n.dataset[e];
          void 0 !== t && (delete n.dataset[e], (0, p.Z)(n, { [e]: t }));
        }
        setContainerStyle(e) {
          super.setContainerStyle(e);
          const n = this.getElement();
          if (((0, Ro.Z)(n, "modal-open"), !e.scrollBarWidth)) return;
          const t = this.isRTL ? "paddingLeft" : "paddingRight",
            o = this.isRTL ? "marginLeft" : "marginRight";
          (0, $o.Z)(n, Fo).forEach((n) =>
            this.adjustAndStore(t, n, e.scrollBarWidth)
          ),
            (0, $o.Z)(n, So).forEach((n) =>
              this.adjustAndStore(o, n, -e.scrollBarWidth)
            ),
            (0, $o.Z)(n, Bo).forEach((n) =>
              this.adjustAndStore(o, n, e.scrollBarWidth)
            );
        }
        removeContainerStyle(e) {
          super.removeContainerStyle(e);
          const n = this.getElement();
          (0, Zo.Z)(n, "modal-open");
          const t = this.isRTL ? "paddingLeft" : "paddingRight",
            o = this.isRTL ? "marginLeft" : "marginRight";
          (0, $o.Z)(n, Fo).forEach((e) => this.restore(t, e)),
            (0, $o.Z)(n, So).forEach((e) => this.restore(o, e)),
            (0, $o.Z)(n, Bo).forEach((e) => this.restore(o, e));
        }
      }
      let Ao;
      function Lo(e) {
        return Ao || (Ao = new Mo(e)), Ao;
      }
      const Ho = Mo,
        Do = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "modal-body")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Do.displayName = "ModalBody";
      const zo = Do,
        Ko = s.createContext({ onHide() {} }),
        _o = {
          bsPrefix: c().string,
          contentClassName: c().string,
          size: c().string,
          fullscreen: c().oneOfType([c().bool, c().string]),
          centered: c().bool,
          scrollable: c().bool,
        },
        Go = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            contentClassName: s,
            centered: r,
            size: a,
            fullscreen: l,
            children: c,
            scrollable: d,
            ...p
          } = e;
          t = (0, u.vE)(t, "modal");
          const f = `${t}-dialog`,
            m =
              "string" == typeof l ? `${t}-fullscreen-${l}` : `${t}-fullscreen`;
          return (0, h.jsx)("div", {
            ...p,
            ref: n,
            className: i()(
              f,
              o,
              a && `${t}-${a}`,
              r && `${f}-centered`,
              d && `${f}-scrollable`,
              l && m
            ),
            children: (0, h.jsx)("div", {
              className: i()(`${t}-content`, s),
              children: c,
            }),
          });
        });
      (Go.displayName = "ModalDialog"), (Go.propTypes = _o);
      const Vo = Go,
        qo = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "modal-footer")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      qo.displayName = "ModalFooter";
      const Uo = qo,
        Wo = {
          closeLabel: c().string,
          closeVariant: c().oneOf(["white"]),
          closeButton: c().bool,
          onHide: c().func,
        },
        Xo = s.forwardRef((e, n) => {
          let {
            closeLabel: t = "Close",
            closeVariant: o,
            closeButton: r = !1,
            onHide: a,
            children: i,
            ...l
          } = e;
          const c = (0, s.useContext)(Ko),
            d = (0, We.Z)(() => {
              c?.onHide(), a?.();
            });
          return (0, h.jsxs)("div", {
            ref: n,
            ...l,
            children: [
              i,
              r &&
                (0, h.jsx)(dn.Z, { "aria-label": t, variant: o, onClick: d }),
            ],
          });
        });
      Xo.propTypes = Wo;
      const Yo = Xo,
        Jo = {
          bsPrefix: c().string,
          closeLabel: c().string,
          closeVariant: c().oneOf(["white"]),
          closeButton: c().bool,
          onHide: c().func,
        },
        Qo = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            closeLabel: s = "Close",
            closeButton: r = !1,
            ...a
          } = e;
          return (
            (t = (0, u.vE)(t, "modal-header")),
            (0, h.jsx)(Yo, {
              ref: n,
              ...a,
              className: i()(o, t),
              closeLabel: s,
              closeButton: r,
            })
          );
        });
      (Qo.displayName = "ModalHeader"), (Qo.propTypes = Jo);
      const es = Qo,
        ns = (0, Se.Z)("h4"),
        ts = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = ns, ...r } = e;
          return (
            (o = (0, u.vE)(o, "modal-title")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      ts.displayName = "ModalTitle";
      const os = ts,
        ss = {
          bsPrefix: c().string,
          size: c().string,
          fullscreen: c().oneOfType([c().bool, c().string]),
          centered: c().bool,
          backdrop: c().oneOf(["static", !0, !1]),
          backdropClassName: c().string,
          keyboard: c().bool,
          scrollable: c().bool,
          animation: c().bool,
          dialogClassName: c().string,
          contentClassName: c().string,
          dialogAs: c().elementType,
          autoFocus: c().bool,
          enforceFocus: c().bool,
          restoreFocus: c().bool,
          restoreFocusOptions: c().shape({ preventScroll: c().bool }),
          show: c().bool,
          onShow: c().func,
          onHide: c().func,
          onEscapeKeyDown: c().func,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
          manager: c().object,
          container: c().any,
          "data-bs-theme": c().string,
          "aria-labelledby": c().string,
          "aria-describedby": c().string,
          "aria-label": c().string,
        };
      function rs(e) {
        return (0, h.jsx)(ct.Z, { ...e, timeout: null });
      }
      function as(e) {
        return (0, h.jsx)(ct.Z, { ...e, timeout: null });
      }
      const is = s.forwardRef((e, n) => {
        let {
          bsPrefix: t,
          className: o,
          style: r,
          dialogClassName: a,
          contentClassName: l,
          children: c,
          dialogAs: d = Vo,
          "data-bs-theme": p,
          "aria-labelledby": f,
          "aria-describedby": m,
          "aria-label": b,
          show: x = !1,
          animation: g = !0,
          backdrop: v = !0,
          keyboard: y = !0,
          onEscapeKeyDown: j,
          onShow: N,
          onHide: C,
          container: E,
          autoFocus: w = !0,
          enforceFocus: T = !0,
          restoreFocus: P = !0,
          restoreFocusOptions: O,
          onEntered: k,
          onExit: R,
          onExiting: $,
          onEnter: Z,
          onEntering: I,
          onExited: F,
          backdropClassName: S,
          manager: B,
          ...M
        } = e;
        const [A, L] = (0, s.useState)({}),
          [H, D] = (0, s.useState)(!1),
          z = (0, s.useRef)(!1),
          K = (0, s.useRef)(!1),
          _ = (0, s.useRef)(null),
          [G, V] = (0, To.Z)(),
          q = (0, Bn.Z)(n, V),
          U = (0, We.Z)(C),
          W = (0, u.SC)();
        t = (0, u.vE)(t, "modal");
        const X = (0, s.useMemo)(() => ({ onHide: U }), [U]);
        function Y() {
          return B || Lo({ isRTL: W });
        }
        function J(e) {
          if (!No.Z) return;
          const n = Y().getScrollbarWidth() > 0,
            t = e.scrollHeight > (0, Co.Z)(e).documentElement.clientHeight;
          L({
            paddingRight: n && !t ? (0, wo.Z)() : void 0,
            paddingLeft: !n && t ? (0, wo.Z)() : void 0,
          });
        }
        const Q = (0, We.Z)(() => {
          G && J(G.dialog);
        });
        (0, Po.Z)(() => {
          (0, Eo.Z)(window, "resize", Q), _.current?.();
        });
        const ee = () => {
            z.current = !0;
          },
          ne = (e) => {
            z.current && G && e.target === G.dialog && (K.current = !0),
              (z.current = !1);
          },
          te = () => {
            D(!0),
              (_.current = (0, Oo.Z)(G.dialog, () => {
                D(!1);
              }));
          },
          oe = (e) => {
            "static" !== v
              ? K.current || e.target !== e.currentTarget
                ? (K.current = !1)
                : C?.()
              : ((e) => {
                  e.target === e.currentTarget && te();
                })(e);
          },
          se = (0, s.useCallback)(
            (e) =>
              (0, h.jsx)("div", {
                ...e,
                className: i()(`${t}-backdrop`, S, !g && "show"),
              }),
            [g, S, t]
          ),
          re = { ...r, ...A };
        re.display = "block";
        return (0, h.jsx)(Ko.Provider, {
          value: X,
          children: (0, h.jsx)(ko.Z, {
            show: x,
            ref: q,
            backdrop: v,
            container: E,
            keyboard: !0,
            autoFocus: w,
            enforceFocus: T,
            restoreFocus: P,
            restoreFocusOptions: O,
            onEscapeKeyDown: (e) => {
              y ? j?.(e) : (e.preventDefault(), "static" === v && te());
            },
            onShow: N,
            onHide: C,
            onEnter: (e, n) => {
              e && J(e), Z?.(e, n);
            },
            onEntering: (e, n) => {
              I?.(e, n), (0, jo.ZP)(window, "resize", Q);
            },
            onEntered: k,
            onExit: (e) => {
              _.current?.(), R?.(e);
            },
            onExiting: $,
            onExited: (e) => {
              e && (e.style.display = ""),
                F?.(e),
                (0, Eo.Z)(window, "resize", Q);
            },
            manager: Y(),
            transition: g ? rs : void 0,
            backdropTransition: g ? as : void 0,
            renderBackdrop: se,
            renderDialog: (e) =>
              (0, h.jsx)("div", {
                role: "dialog",
                ...e,
                style: re,
                className: i()(o, t, H && `${t}-static`, !g && "show"),
                onClick: v ? oe : void 0,
                onMouseUp: ne,
                "data-bs-theme": p,
                "aria-label": b,
                "aria-labelledby": f,
                "aria-describedby": m,
                children: (0, h.jsx)(d, {
                  ...M,
                  onMouseDown: ee,
                  className: a,
                  contentClassName: l,
                  children: c,
                }),
              }),
          }),
        });
      });
      (is.displayName = "Modal"), (is.propTypes = ss);
      const ls = Object.assign(is, {
        Body: zo,
        Header: es,
        Title: os,
        Footer: Uo,
        Dialog: Vo,
        TRANSITION_DURATION: 300,
        BACKDROP_TRANSITION_DURATION: 150,
      });
      var cs = t(33407),
        ds = t.n(cs);
      const us = s.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
        return (
          (o = (0, u.vE)(o, "nav-item")),
          (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
        );
      });
      us.displayName = "NavItem";
      const ps = us,
        fs = {
          bsPrefix: c().string,
          active: c().bool,
          disabled: c().bool,
          role: c().string,
          href: c().string,
          eventKey: c().oneOfType([c().string, c().number]),
          as: c().elementType,
        },
        ms = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            as: s = J.Z,
            active: r,
            eventKey: a,
            disabled: l = !1,
            ...c
          } = e;
          t = (0, u.vE)(t, "nav-link");
          const [d, p] = (0, fo.v)({
            key: (0, mo.h)(a, c.href),
            active: r,
            disabled: l,
            ...c,
          });
          return (0, h.jsx)(s, {
            ...c,
            ...d,
            ref: n,
            disabled: l,
            className: i()(o, t, l && "disabled", p.isActive && "active"),
          });
        });
      (ms.displayName = "NavLink"), (ms.propTypes = fs);
      const bs = ms,
        xs = {
          bsPrefix: c().string,
          navbarBsPrefix: c().string,
          cardHeaderBsPrefix: c().string,
          variant: c().string,
          activeKey: c().oneOfType([c().string, c().number]),
          defaultActiveKey: c().oneOfType([c().string, c().number]),
          fill: c().bool,
          justify: ds()(c().bool, (e) => {
            let { justify: n, navbar: t } = e;
            return n && t
              ? Error("justify navbar `Nav`s are not supported")
              : null;
          }),
          onSelect: c().func,
          role: c().string,
          navbar: c().bool,
          navbarScroll: c().bool,
          as: c().elementType,
          onKeyDown: c().func,
        },
        gs = s.forwardRef((e, n) => {
          const {
              as: t = "div",
              bsPrefix: o,
              variant: r,
              fill: a = !1,
              justify: l = !1,
              navbar: c,
              navbarScroll: p,
              className: f,
              activeKey: m,
              ...b
            } = (0, d.Ch)(e, { activeKey: "onSelect" }),
            x = (0, u.vE)(o, "nav");
          let g,
            v,
            y = !1;
          const j = (0, s.useContext)(zn),
            N = (0, s.useContext)(Ee);
          return (
            j
              ? ((g = j.bsPrefix), (y = null == c || c))
              : N && ({ cardHeaderBsPrefix: v } = N),
            (0, h.jsx)(po.Z, {
              as: t,
              ref: n,
              activeKey: m,
              className: i()(f, {
                [x]: !y,
                [`${g}-nav`]: y,
                [`${g}-nav-scroll`]: y && p,
                [`${v}-${r}`]: !!v,
                [`${x}-${r}`]: !!r,
                [`${x}-fill`]: a,
                [`${x}-justified`]: l,
              }),
              ...b,
            })
          );
        });
      (gs.displayName = "Nav"), (gs.propTypes = xs);
      const hs = Object.assign(gs, { Item: ps, Link: bs }),
        vs = { bsPrefix: c().string, href: c().string, as: c().elementType },
        ys = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, as: s, ...r } = e;
          t = (0, u.vE)(t, "navbar-brand");
          const a = s || (r.href ? "a" : "span");
          return (0, h.jsx)(a, { ...r, ref: n, className: i()(o, t) });
        });
      (ys.displayName = "NavbarBrand"), (ys.propTypes = vs);
      const js = ys,
        Ns = { bsPrefix: c().string },
        Cs = s.forwardRef((e, n) => {
          let { children: t, bsPrefix: o, ...r } = e;
          o = (0, u.vE)(o, "navbar-collapse");
          const a = (0, s.useContext)(zn);
          return (0, h.jsx)(E, {
            in: !(!a || !a.expanded),
            ...r,
            children: (0, h.jsx)("div", { ref: n, className: o, children: t }),
          });
        });
      (Cs.displayName = "NavbarCollapse"), (Cs.propTypes = Ns);
      const Es = Cs,
        ws = {
          bsPrefix: c().string,
          label: c().string,
          onClick: c().func,
          children: c().node,
          as: c().elementType,
        },
        Ts = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            children: r,
            label: a = "Toggle navigation",
            as: l = "button",
            onClick: c,
            ...d
          } = e;
          t = (0, u.vE)(t, "navbar-toggler");
          const { onToggle: p, expanded: f } = (0, s.useContext)(zn) || {},
            m = (0, We.Z)((e) => {
              c && c(e), p && p();
            });
          return (
            "button" === l && (d.type = "button"),
            (0, h.jsx)(l, {
              ...d,
              ref: n,
              onClick: m,
              "aria-label": a,
              className: i()(o, t, !f && "collapsed"),
              children: r || (0, h.jsx)("span", { className: `${t}-icon` }),
            })
          );
        });
      (Ts.displayName = "NavbarToggle"), (Ts.propTypes = ws);
      const Ps = Ts;
      var Os = t(46353);
      const ks = s.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
        return (
          (o = (0, u.vE)(o, "offcanvas-body")),
          (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
        );
      });
      ks.displayName = "OffcanvasBody";
      const Rs = ks,
        $s = {
          in: c().bool,
          mountOnEnter: c().bool,
          unmountOnExit: c().bool,
          appear: c().bool,
          timeout: c().number,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
        },
        Zs = { [f.d0]: "show", [f.cn]: "show" },
        Is = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            children: r,
            in: a = !1,
            mountOnEnter: l = !1,
            unmountOnExit: c = !1,
            appear: d = !1,
            ...p
          } = e;
          return (
            (t = (0, u.vE)(t, "offcanvas")),
            (0, h.jsx)(g.Z, {
              ref: n,
              addEndListener: m.Z,
              in: a,
              mountOnEnter: l,
              unmountOnExit: c,
              appear: d,
              ...p,
              childRef: r.ref,
              children: (e, n) =>
                s.cloneElement(r, {
                  ...n,
                  className: i()(
                    o,
                    r.props.className,
                    (e === f.d0 || e === f.Ix) && `${t}-toggling`,
                    Zs[e]
                  ),
                }),
            })
          );
        });
      (Is.propTypes = $s), (Is.displayName = "OffcanvasToggling");
      const Fs = Is,
        Ss = {
          bsPrefix: c().string,
          closeLabel: c().string,
          closeVariant: c().oneOf(["white"]),
          closeButton: c().bool,
          onHide: c().func,
        },
        Bs = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            closeLabel: s = "Close",
            closeButton: r = !1,
            ...a
          } = e;
          return (
            (t = (0, u.vE)(t, "offcanvas-header")),
            (0, h.jsx)(Yo, {
              ref: n,
              ...a,
              className: i()(o, t),
              closeLabel: s,
              closeButton: r,
            })
          );
        });
      (Bs.displayName = "OffcanvasHeader"), (Bs.propTypes = Ss);
      const Ms = Bs,
        As = (0, Se.Z)("h5"),
        Ls = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = As, ...r } = e;
          return (
            (o = (0, u.vE)(o, "offcanvas-title")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Ls.displayName = "OffcanvasTitle";
      const Hs = Ls,
        Ds = {
          bsPrefix: c().string,
          backdrop: c().oneOf(["static", !0, !1]),
          backdropClassName: c().string,
          keyboard: c().bool,
          scroll: c().bool,
          placement: c().oneOf(["start", "end", "top", "bottom"]),
          responsive: c().string,
          autoFocus: c().bool,
          enforceFocus: c().bool,
          restoreFocus: c().bool,
          restoreFocusOptions: c().shape({ preventScroll: c().bool }),
          show: c().bool,
          onShow: c().func,
          onHide: c().func,
          onEscapeKeyDown: c().func,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
          container: c().any,
          renderStaticNode: c().bool,
          "aria-labelledby": c().string,
        };
      function zs(e) {
        return (0, h.jsx)(Fs, { ...e });
      }
      function Ks(e) {
        return (0, h.jsx)(ct.Z, { ...e });
      }
      const _s = s.forwardRef((e, n) => {
        let {
          bsPrefix: t,
          className: o,
          children: r,
          "aria-labelledby": a,
          placement: l = "start",
          responsive: c,
          show: d = !1,
          backdrop: p = !0,
          keyboard: f = !0,
          scroll: m = !1,
          onEscapeKeyDown: b,
          onShow: x,
          onHide: g,
          container: v,
          autoFocus: y = !0,
          enforceFocus: j = !0,
          restoreFocus: N = !0,
          restoreFocusOptions: C,
          onEntered: E,
          onExit: w,
          onExiting: T,
          onEnter: P,
          onEntering: O,
          onExited: k,
          backdropClassName: R,
          manager: $,
          renderStaticNode: Z = !1,
          ...I
        } = e;
        const F = (0, s.useRef)();
        t = (0, u.vE)(t, "offcanvas");
        const { onToggle: S } = (0, s.useContext)(zn) || {},
          [B, M] = (0, s.useState)(!1),
          A = (0, Os.Z)(c || "xs", "up");
        (0, s.useEffect)(() => {
          M(c ? d && !A : d);
        }, [d, c, A]);
        const L = (0, We.Z)(() => {
            S?.(), g?.();
          }),
          H = (0, s.useMemo)(() => ({ onHide: L }), [L]);
        const D = (0, s.useCallback)(
            (e) =>
              (0, h.jsx)("div", { ...e, className: i()(`${t}-backdrop`, R) }),
            [R, t]
          ),
          z = (e) =>
            (0, h.jsx)("div", {
              ...e,
              ...I,
              className: i()(o, c ? `${t}-${c}` : t, `${t}-${l}`),
              "aria-labelledby": a,
              children: r,
            });
        return (0, h.jsxs)(h.Fragment, {
          children: [
            !B && (c || Z) && z({}),
            (0, h.jsx)(Ko.Provider, {
              value: H,
              children: (0, h.jsx)(ko.Z, {
                show: B,
                ref: n,
                backdrop: p,
                container: v,
                keyboard: f,
                autoFocus: y,
                enforceFocus: j && !m,
                restoreFocus: N,
                restoreFocusOptions: C,
                onEscapeKeyDown: b,
                onShow: x,
                onHide: L,
                onEnter: function (e) {
                  e && (e.style.visibility = "visible");
                  for (
                    var n = arguments.length,
                      t = new Array(n > 1 ? n - 1 : 0),
                      o = 1;
                    o < n;
                    o++
                  )
                    t[o - 1] = arguments[o];
                  P?.(e, ...t);
                },
                onEntering: O,
                onEntered: E,
                onExit: w,
                onExiting: T,
                onExited: function (e) {
                  e && (e.style.visibility = "");
                  for (
                    var n = arguments.length,
                      t = new Array(n > 1 ? n - 1 : 0),
                      o = 1;
                    o < n;
                    o++
                  )
                    t[o - 1] = arguments[o];
                  k?.(...t);
                },
                manager:
                  $ ||
                  (m
                    ? (F.current ||
                        (F.current = new Ho({ handleContainerOverflow: !1 })),
                      F.current)
                    : Lo()),
                transition: zs,
                backdropTransition: Ks,
                renderBackdrop: D,
                renderDialog: z,
              }),
            }),
          ],
        });
      });
      (_s.displayName = "Offcanvas"), (_s.propTypes = Ds);
      const Gs = Object.assign(_s, { Body: Rs, Header: Ms, Title: Hs }),
        Vs = s.forwardRef((e, n) => {
          const t = (0, s.useContext)(zn);
          return (0, h.jsx)(Gs, {
            ref: n,
            show: !!t?.expanded,
            ...e,
            renderStaticNode: !0,
          });
        });
      Vs.displayName = "NavbarOffcanvas";
      const qs = Vs,
        Us = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "span", ...r } = e;
          return (
            (o = (0, u.vE)(o, "navbar-text")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Us.displayName = "NavbarText";
      const Ws = Us,
        Xs = {
          bsPrefix: c().string,
          variant: c().string,
          expand: c().oneOfType([c().bool, c().string]),
          bg: c().string,
          fixed: c().oneOf(["top", "bottom"]),
          sticky: c().oneOf(["top", "bottom"]),
          as: c().elementType,
          onToggle: c().func,
          onSelect: c().func,
          collapseOnSelect: c().bool,
          expanded: c().bool,
          role: c().string,
        },
        Ys = s.forwardRef((e, n) => {
          const {
              bsPrefix: t,
              expand: o = !0,
              variant: r = "light",
              bg: a,
              fixed: l,
              sticky: c,
              className: p,
              as: f = "nav",
              expanded: m,
              onToggle: b,
              onSelect: x,
              collapseOnSelect: g = !1,
              ...v
            } = (0, d.Ch)(e, { expanded: "onToggle" }),
            y = (0, u.vE)(t, "navbar"),
            j = (0, s.useCallback)(
              function () {
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                x?.(...n), g && m && b?.(!1);
              },
              [x, g, m, b]
            );
          void 0 === v.role && "nav" !== f && (v.role = "navigation");
          let N = `${y}-expand`;
          "string" == typeof o && (N = `${N}-${o}`);
          const C = (0, s.useMemo)(
            () => ({
              onToggle: () => b?.(!m),
              bsPrefix: y,
              expanded: !!m,
              expand: o,
            }),
            [y, m, o, b]
          );
          return (0, h.jsx)(zn.Provider, {
            value: C,
            children: (0, h.jsx)(mo.Z.Provider, {
              value: j,
              children: (0, h.jsx)(f, {
                ref: n,
                ...v,
                className: i()(
                  p,
                  y,
                  o && N,
                  r && `${y}-${r}`,
                  a && `bg-${a}`,
                  c && `sticky-${c}`,
                  l && `fixed-${l}`
                ),
              }),
            }),
          });
        });
      (Ys.propTypes = Xs), (Ys.displayName = "Navbar");
      const Js = Object.assign(Ys, {
          Brand: js,
          Collapse: Es,
          Offcanvas: qs,
          Text: Ws,
          Toggle: Ps,
        }),
        Qs = {
          id: c().string,
          onClick: c().func,
          title: c().node.isRequired,
          disabled: c().bool,
          active: c().bool,
          menuRole: c().string,
          renderMenuOnMount: c().bool,
          rootCloseEvent: c().string,
          menuVariant: c().oneOf(["dark"]),
          bsPrefix: c().string,
        },
        er = s.forwardRef((e, n) => {
          let {
            id: t,
            title: o,
            children: s,
            bsPrefix: r,
            className: a,
            rootCloseEvent: l,
            menuRole: c,
            disabled: d,
            active: p,
            renderMenuOnMount: f,
            menuVariant: m,
            ...b
          } = e;
          const x = (0, u.vE)(void 0, "nav-item");
          return (0, h.jsxs)(rt, {
            ref: n,
            ...b,
            className: i()(a, x),
            children: [
              (0, h.jsx)(rt.Toggle, {
                id: t,
                eventKey: null,
                active: p,
                disabled: d,
                childBsPrefix: r,
                as: bs,
                children: o,
              }),
              (0, h.jsx)(rt.Menu, {
                role: c,
                renderOnMount: f,
                rootCloseEvent: l,
                variant: m,
                children: s,
              }),
            ],
          });
        });
      (er.displayName = "NavDropdown"), (er.propTypes = Qs);
      const nr = Object.assign(er, {
        Item: rt.Item,
        ItemText: rt.ItemText,
        Divider: rt.Divider,
        Header: rt.Header,
      });
      var tr = t(74002),
        or = t(86191),
        sr = t(57353);
      const rr = s.forwardRef((e, n) => {
        let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
        return (
          (o = (0, u.vE)(o, "popover-header")),
          (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
        );
      });
      rr.displayName = "PopoverHeader";
      const ar = rr,
        ir = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "popover-body")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      ir.displayName = "PopoverBody";
      const lr = ir;
      s.Component;
      function cr(e, n) {
        let t = e;
        return (
          "left" === e
            ? (t = n ? "end" : "start")
            : "right" === e && (t = n ? "start" : "end"),
          t
        );
      }
      function dr(e) {
        return (
          void 0 === e && (e = "absolute"),
          {
            position: e,
            top: "0",
            left: "0",
            opacity: "0",
            pointerEvents: "none",
          }
        );
      }
      const ur = {
          bsPrefix: c().string,
          id: c().string,
          placement: c().oneOf([
            "auto-start",
            "auto",
            "auto-end",
            "top-start",
            "top",
            "top-end",
            "right-start",
            "right",
            "right-end",
            "bottom-end",
            "bottom",
            "bottom-start",
            "left-end",
            "left",
            "left-start",
          ]),
          arrowProps: c().shape({ ref: c().any, style: c().object }),
          body: c().bool,
          hasDoneInitialMeasure: c().bool,
          popper: c().object,
          show: c().bool,
        },
        pr = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            placement: o = "right",
            className: s,
            style: r,
            children: a,
            body: l,
            arrowProps: c,
            hasDoneInitialMeasure: d,
            popper: p,
            show: f,
            ...m
          } = e;
          const b = (0, u.vE)(t, "popover"),
            x = (0, u.SC)(),
            [g] = o?.split("-") || [],
            v = cr(g, x);
          let y = r;
          return (
            f && !d && (y = { ...r, ...dr(p?.strategy) }),
            (0, h.jsxs)("div", {
              ref: n,
              role: "tooltip",
              style: y,
              "x-placement": g,
              className: i()(s, b, g && `bs-popover-${v}`),
              ...m,
              children: [
                (0, h.jsx)("div", { className: "popover-arrow", ...c }),
                l ? (0, h.jsx)(lr, { children: a }) : a,
              ],
            })
          );
        });
      pr.propTypes = ur;
      const fr = Object.assign(pr, {
          Header: ar,
          Body: lr,
          POPPER_OFFSET: [0, 8],
        }),
        mr = {
          bsPrefix: c().string,
          id: c().string,
          placement: c().oneOf([
            "auto-start",
            "auto",
            "auto-end",
            "top-start",
            "top",
            "top-end",
            "right-start",
            "right",
            "right-end",
            "bottom-end",
            "bottom",
            "bottom-start",
            "left-end",
            "left",
            "left-start",
          ]),
          arrowProps: c().shape({ ref: c().any, style: c().object }),
          hasDoneInitialMeasure: c().bool,
          popper: c().object,
          show: c().any,
        },
        br = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            placement: o = "right",
            className: s,
            style: r,
            children: a,
            arrowProps: l,
            hasDoneInitialMeasure: c,
            popper: d,
            show: p,
            ...f
          } = e;
          t = (0, u.vE)(t, "tooltip");
          const m = (0, u.SC)(),
            [b] = o?.split("-") || [],
            x = cr(b, m);
          let g = r;
          return (
            p && !c && (g = { ...r, ...dr(d?.strategy) }),
            (0, h.jsxs)("div", {
              ref: n,
              style: g,
              role: "tooltip",
              "x-placement": b,
              className: i()(s, t, `bs-tooltip-${x}`),
              ...f,
              children: [
                (0, h.jsx)("div", { className: "tooltip-arrow", ...l }),
                (0, h.jsx)("div", { className: `${t}-inner`, children: a }),
              ],
            })
          );
        });
      (br.propTypes = mr), (br.displayName = "Tooltip");
      const xr = Object.assign(br, { TOOLTIP_OFFSET: [0, 6] });
      var gr = t(63745);
      const hr = {
        container: c().oneOfType([or.ax, c().func]),
        target: c().oneOfType([or.ax, c().func]),
        show: c().bool,
        popperConfig: c().object,
        rootClose: c().bool,
        rootCloseEvent: c().oneOf(["click", "mousedown"]),
        onHide: c().func,
        transition: c().oneOfType([c().bool, or.nm]),
        onEnter: c().func,
        onEntering: c().func,
        onEntered: c().func,
        onExit: c().func,
        onExiting: c().func,
        onExited: c().func,
        placement: c().oneOf([
          "auto-start",
          "auto",
          "auto-end",
          "top-start",
          "top",
          "top-end",
          "right-start",
          "right",
          "right-end",
          "bottom-end",
          "bottom",
          "bottom-start",
          "left-end",
          "left",
          "left-start",
        ]),
      };
      const vr = s.forwardRef((e, n) => {
        let {
          children: t,
          transition: o = ct.Z,
          popperConfig: r = {},
          rootClose: a = !1,
          placement: l = "top",
          show: c = !1,
          ...d
        } = e;
        const p = (0, s.useRef)({}),
          [f, m] = (0, s.useState)(null),
          [b, x] = (function (e) {
            const n = (0, s.useRef)(null),
              t = (0, u.vE)(void 0, "popover"),
              o = (0, u.vE)(void 0, "tooltip"),
              r = (0, s.useMemo)(
                () => ({
                  name: "offset",
                  options: {
                    offset: () => {
                      if (e) return e;
                      if (n.current) {
                        if ((0, sr.Z)(n.current, t)) return fr.POPPER_OFFSET;
                        if ((0, sr.Z)(n.current, o)) return xr.TOOLTIP_OFFSET;
                      }
                      return [0, 0];
                    },
                  },
                }),
                [e, t, o]
              );
            return [n, [r]];
          })(d.offset),
          g = (0, Bn.Z)(n, b),
          v = !0 === o ? ct.Z : o || void 0,
          y = (0, We.Z)((e) => {
            m(e), r?.onFirstUpdate?.(e);
          });
        return (
          (0, Sn.Z)(() => {
            f && d.target && p.current.scheduleUpdate?.();
          }, [f, d.target]),
          (0, s.useEffect)(() => {
            c || m(null);
          }, [c]),
          (0, h.jsx)(tr.Z, {
            ...d,
            ref: g,
            popperConfig: {
              ...r,
              modifiers: x.concat(r.modifiers || []),
              onFirstUpdate: y,
            },
            transition: v,
            rootClose: a,
            placement: l,
            show: c,
            children: (e, n) => {
              let { arrowProps: a, popper: l, show: c } = n;
              !(function (e, n) {
                const { ref: t } = e,
                  { ref: o } = n;
                (e.ref = t.__wrapped || (t.__wrapped = (e) => t((0, gr.Z)(e)))),
                  (n.ref =
                    o.__wrapped || (o.__wrapped = (e) => o((0, gr.Z)(e))));
              })(e, a);
              const d = l?.placement,
                u = Object.assign(p.current, {
                  state: l?.state,
                  scheduleUpdate: l?.update,
                  placement: d,
                  outOfBoundaries:
                    l?.state?.modifiersData.hide?.isReferenceHidden || !1,
                  strategy: r.strategy,
                }),
                m = !!f;
              return "function" == typeof t
                ? t({
                    ...e,
                    placement: d,
                    show: c,
                    ...(!o && c && { className: "show" }),
                    popper: u,
                    arrowProps: a,
                    hasDoneInitialMeasure: m,
                  })
                : s.cloneElement(t, {
                    ...e,
                    placement: d,
                    arrowProps: a,
                    popper: u,
                    hasDoneInitialMeasure: m,
                    className: i()(t.props.className, !o && c && "show"),
                    style: { ...t.props.style, ...e.style },
                  });
            },
          })
        );
      });
      (vr.displayName = "Overlay"), (vr.propTypes = hr);
      const yr = vr;
      var jr = t(19874);
      function Nr(e, n, t) {
        const [o] = n,
          s = o.currentTarget,
          r = o.relatedTarget || o.nativeEvent[t];
        (r && r === s) || (0, jr.Z)(s, r) || e(...n);
      }
      const Cr = c().oneOf(["click", "hover", "focus"]),
        Er = {
          children: c().oneOfType([c().element, c().func]).isRequired,
          trigger: c().oneOfType([Cr.isRequired, c().arrayOf(Cr.isRequired)]),
          delay: c().oneOfType([
            c().number.isRequired,
            c().shape({
              show: c().number.isRequired,
              hide: c().number.isRequired,
            }),
          ]),
          show: c().bool,
          defaultShow: c().bool,
          onToggle: c().func,
          flip: c().bool,
          overlay: c().oneOfType([c().func, c().element.isRequired]).isRequired,
          popperConfig: c().object,
          target: c().oneOf([null]),
          onHide: c().oneOf([null]),
          placement: c().oneOf([
            "auto-start",
            "auto",
            "auto-end",
            "top-start",
            "top",
            "top-end",
            "right-start",
            "right",
            "right-end",
            "bottom-end",
            "bottom",
            "bottom-start",
            "left-end",
            "left",
            "left-start",
          ]),
        },
        wr = (e) => {
          let {
            trigger: n = ["hover", "focus"],
            overlay: t,
            children: o,
            popperConfig: r = {},
            show: a,
            defaultShow: i = !1,
            onToggle: l,
            delay: c,
            placement: u,
            flip: p = u && -1 !== u.indexOf("auto"),
            ...f
          } = e;
          const m = (0, s.useRef)(null),
            b = (0, Bn.Z)(m, o.ref),
            x = (0, Je.Z)(),
            g = (0, s.useRef)(""),
            [v, y] = (0, d.$c)(a, i, l),
            j = (function (e) {
              return e && "object" == typeof e ? e : { show: e, hide: e };
            })(c),
            {
              onFocus: N,
              onBlur: C,
              onClick: E,
            } = "function" != typeof o ? s.Children.only(o).props : {},
            w = (0, s.useCallback)(() => {
              x.clear(),
                (g.current = "show"),
                j.show
                  ? x.set(() => {
                      "show" === g.current && y(!0);
                    }, j.show)
                  : y(!0);
            }, [j.show, y, x]),
            T = (0, s.useCallback)(() => {
              x.clear(),
                (g.current = "hide"),
                j.hide
                  ? x.set(() => {
                      "hide" === g.current && y(!1);
                    }, j.hide)
                  : y(!1);
            }, [j.hide, y, x]),
            P = (0, s.useCallback)(
              function () {
                w();
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                N?.(...n);
              },
              [w, N]
            ),
            O = (0, s.useCallback)(
              function () {
                T();
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                C?.(...n);
              },
              [T, C]
            ),
            k = (0, s.useCallback)(
              function () {
                y(!v);
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                E?.(...n);
              },
              [E, y, v]
            ),
            R = (0, s.useCallback)(
              function () {
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                Nr(w, n, "fromElement");
              },
              [w]
            ),
            $ = (0, s.useCallback)(
              function () {
                for (
                  var e = arguments.length, n = new Array(e), t = 0;
                  t < e;
                  t++
                )
                  n[t] = arguments[t];
                Nr(T, n, "toElement");
              },
              [T]
            ),
            Z = null == n ? [] : [].concat(n),
            I = {
              ref: (e) => {
                b((0, gr.Z)(e));
              },
            };
          return (
            -1 !== Z.indexOf("click") && (I.onClick = k),
            -1 !== Z.indexOf("focus") && ((I.onFocus = P), (I.onBlur = O)),
            -1 !== Z.indexOf("hover") &&
              (An()(
                Z.length > 1,
                '[react-bootstrap] Specifying only the `"hover"` trigger limits the visibility of the overlay to just mouse users. Consider also including the `"focus"` trigger so that touch and keyboard only users can see the overlay as well.'
              ),
              (I.onMouseOver = R),
              (I.onMouseOut = $)),
            (0, h.jsxs)(h.Fragment, {
              children: [
                "function" == typeof o ? o(I) : (0, s.cloneElement)(o, I),
                (0, h.jsx)(yr, {
                  ...f,
                  show: v,
                  onHide: T,
                  flip: p,
                  placement: u,
                  popperConfig: r,
                  target: m.current,
                  children: t,
                }),
              ],
            })
          );
        };
      wr.propTypes = Er;
      const Tr = wr,
        Pr = {
          disabled: c().bool,
          active: c().bool,
          activeLabel: c().string,
          href: c().string,
          onClick: c().func,
          linkStyle: c().object,
          linkClassName: c().string,
        },
        Or = s.forwardRef((e, n) => {
          let {
            active: t = !1,
            disabled: o = !1,
            className: s,
            style: r,
            activeLabel: a = "(current)",
            children: l,
            linkStyle: c,
            linkClassName: d,
            as: u = J.Z,
            ...p
          } = e;
          const f = t || o ? "span" : u;
          return (0, h.jsx)("li", {
            ref: n,
            style: r,
            className: i()(s, "page-item", { active: t, disabled: o }),
            children: (0, h.jsxs)(f, {
              className: i()("page-link", d),
              style: c,
              ...p,
              children: [
                l,
                t &&
                  a &&
                  (0, h.jsx)("span", {
                    className: "visually-hidden",
                    children: a,
                  }),
              ],
            }),
          });
        });
      (Or.propTypes = Pr), (Or.displayName = "PageItem");
      const kr = Or;
      function Rr(e, n, t) {
        void 0 === t && (t = e);
        const o = s.forwardRef((e, o) => {
          let { children: s, ...r } = e;
          return (0, h.jsxs)(Or, {
            ...r,
            ref: o,
            children: [
              (0, h.jsx)("span", { "aria-hidden": "true", children: s || n }),
              (0, h.jsx)("span", { className: "visually-hidden", children: t }),
            ],
          });
        });
        return (o.displayName = e), o;
      }
      const $r = Rr("First", "\xab"),
        Zr = Rr("Prev", "\u2039", "Previous"),
        Ir = Rr("Ellipsis", "\u2026", "More"),
        Fr = Rr("Next", "\u203a"),
        Sr = Rr("Last", "\xbb"),
        Br = { bsPrefix: c().string, size: c().oneOf(["sm", "lg"]) },
        Mr = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, size: s, ...r } = e;
          const a = (0, u.vE)(t, "pagination");
          return (0, h.jsx)("ul", {
            ref: n,
            ...r,
            className: i()(o, a, s && `${a}-${s}`),
          });
        });
      (Mr.propTypes = Br), (Mr.displayName = "Pagination");
      const Ar = Object.assign(Mr, {
        First: $r,
        Prev: Zr,
        Ellipsis: Ir,
        Item: kr,
        Next: Fr,
        Last: Sr,
      });
      function Lr(e) {
        let { animation: n, bg: t, bsPrefix: o, size: s, ...r } = e;
        o = (0, u.vE)(o, "placeholder");
        const [{ className: a, ...l }] = bn(r);
        return {
          ...l,
          className: i()(
            a,
            n ? `${o}-${n}` : o,
            s && `${o}-${s}`,
            t && `bg-${t}`
          ),
        };
      }
      const Hr = {
          bsPrefix: c().string,
          animation: c().oneOf(["glow", "wave"]),
          size: c().oneOf(["xs", "sm", "lg"]),
          variant: c().string,
        },
        Dr = s.forwardRef((e, n) => {
          const t = Lr(e);
          return (0, h.jsx)(pe, { ...t, ref: n, disabled: !0, tabIndex: -1 });
        });
      (Dr.displayName = "PlaceholderButton"), (Dr.propTypes = Hr);
      const zr = Dr,
        Kr = {
          bsPrefix: c().string,
          animation: c().string,
          bg: c().string,
          size: c().string,
        },
        _r = s.forwardRef((e, n) => {
          let { as: t = "span", ...o } = e;
          const s = Lr(o);
          return (0, h.jsx)(t, { ...s, ref: n });
        });
      (_r.displayName = "Placeholder"), (_r.propTypes = Kr);
      const Gr = Object.assign(_r, { Button: zr }),
        Vr = 1e3;
      const qr = {
        min: c().number,
        now: c().number,
        max: c().number,
        label: c().node,
        visuallyHidden: c().bool,
        striped: c().bool,
        animated: c().bool,
        bsPrefix: c().string,
        variant: c().string,
        children: function (e, n, t) {
          const o = e[n];
          if (!o) return null;
          let r = null;
          return (
            s.Children.forEach(o, (e) => {
              if (r) return;
              const n = (0, h.jsx)(Xr, {});
              if (e.type === n.type) return;
              const o = e.type,
                a = s.isValidElement(e) ? o.displayName || o.name || o : e;
              r = new Error(
                `Children of ${t} can contain only ProgressBar components. Found ${a}.`
              );
            }),
            r
          );
        },
        isChild: c().bool,
      };
      function Ur(e, n, t) {
        const o = ((e - n) / (t - n)) * 100;
        return Math.round(o * Vr) / Vr;
      }
      function Wr(e, n) {
        let {
          min: t,
          now: o,
          max: s,
          label: r,
          visuallyHidden: a,
          striped: l,
          animated: c,
          className: d,
          style: u,
          variant: p,
          bsPrefix: f,
          ...m
        } = e;
        return (0, h.jsx)("div", {
          ref: n,
          ...m,
          role: "progressbar",
          className: i()(d, `${f}-bar`, {
            [`bg-${p}`]: p,
            [`${f}-bar-animated`]: c,
            [`${f}-bar-striped`]: c || l,
          }),
          style: { width: `${Ur(o, t, s)}%`, ...u },
          "aria-valuenow": o,
          "aria-valuemin": t,
          "aria-valuemax": s,
          children: a
            ? (0, h.jsx)("span", { className: "visually-hidden", children: r })
            : r,
        });
      }
      Wr.propTypes = qr;
      const Xr = s.forwardRef((e, n) => {
        let { isChild: t = !1, ...o } = e;
        const r = {
          min: 0,
          max: 100,
          animated: !1,
          visuallyHidden: !1,
          striped: !1,
          ...o,
        };
        if (((r.bsPrefix = (0, u.vE)(r.bsPrefix, "progress")), t))
          return Wr(r, n);
        const {
          min: a,
          now: l,
          max: c,
          label: d,
          visuallyHidden: p,
          striped: f,
          animated: m,
          bsPrefix: b,
          variant: x,
          className: g,
          children: v,
          ...y
        } = r;
        return (0, h.jsx)("div", {
          ref: n,
          ...y,
          className: i()(g, b),
          children: v
            ? sn(v, (e) => (0, s.cloneElement)(e, { isChild: !0 }))
            : Wr(
                {
                  min: a,
                  now: l,
                  max: c,
                  label: d,
                  visuallyHidden: p,
                  striped: f,
                  animated: m,
                  bsPrefix: b,
                  variant: x,
                },
                n
              ),
        });
      });
      (Xr.displayName = "ProgressBar"), (Xr.propTypes = qr);
      const Yr = Xr,
        Jr = {
          bsPrefix: c().string,
          children: c().element.isRequired,
          aspectRatio: c().oneOfType([c().number, c().string]),
        };
      const Qr = s.forwardRef((e, n) => {
        let {
          bsPrefix: t,
          className: o,
          children: r,
          aspectRatio: a = "1x1",
          style: l,
          ...c
        } = e;
        t = (0, u.vE)(t, "ratio");
        const d = "number" == typeof a;
        return (0, h.jsx)("div", {
          ref: n,
          ...c,
          style: {
            ...l,
            ...(d && {
              "--bs-aspect-ratio":
                ((p = a), p <= 0 ? "100%" : p < 1 ? 100 * p + "%" : `${p}%`),
            }),
          },
          className: i()(t, o, !d && `${t}-${a}`),
          children: s.Children.only(r),
        });
        var p;
      });
      Qr.propTypes = Jr;
      const ea = Qr,
        na = c().oneOfType([c().number, c().string]),
        ta = c().oneOfType([na, c().shape({ cols: na })]),
        oa = {
          bsPrefix: c().string,
          as: c().elementType,
          xs: ta,
          sm: ta,
          md: ta,
          lg: ta,
          xl: ta,
          xxl: ta,
        },
        sa = s.forwardRef((e, n) => {
          let { bsPrefix: t, className: o, as: s = "div", ...r } = e;
          const a = (0, u.vE)(t, "row"),
            l = (0, u.pi)(),
            c = (0, u.zG)(),
            d = `${a}-cols`,
            p = [];
          return (
            l.forEach((e) => {
              const n = r[e];
              let t;
              delete r[e],
                null != n && "object" == typeof n ? ({ cols: t } = n) : (t = n);
              const o = e !== c ? `-${e}` : "";
              null != t && p.push(`${d}${o}-${t}`);
            }),
            (0, h.jsx)(s, { ref: n, ...r, className: i()(o, a, ...p) })
          );
        });
      (sa.displayName = "Row"), (sa.propTypes = oa);
      const ra = sa,
        aa = {
          bsPrefix: c().string,
          variant: c().string,
          animation: c().oneOf(["border", "grow"]).isRequired,
          size: c().string,
          children: c().element,
          role: c().string,
          as: c().elementType,
        },
        ia = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            variant: o,
            animation: s = "border",
            size: r,
            as: a = "div",
            className: l,
            ...c
          } = e;
          t = (0, u.vE)(t, "spinner");
          const d = `${t}-${s}`;
          return (0, h.jsx)(a, {
            ref: n,
            ...c,
            className: i()(l, d, r && `${d}-${r}`, o && `text-${o}`),
          });
        });
      (ia.propTypes = aa), (ia.displayName = "Spinner");
      const la = ia,
        ca = {
          id: c().string,
          toggleLabel: c().string,
          href: c().string,
          target: c().string,
          onClick: c().func,
          title: c().node.isRequired,
          type: c().string,
          disabled: c().bool,
          align: qn,
          menuRole: c().string,
          renderMenuOnMount: c().bool,
          rootCloseEvent: c().string,
          flip: c().bool,
          bsPrefix: c().string,
          variant: c().string,
          size: c().string,
        },
        da = s.forwardRef((e, n) => {
          let {
            id: t,
            bsPrefix: o,
            size: s,
            variant: r,
            title: a,
            type: i = "button",
            toggleLabel: l = "Toggle dropdown",
            children: c,
            onClick: d,
            href: u,
            target: p,
            menuRole: f,
            renderMenuOnMount: m,
            rootCloseEvent: b,
            flip: x,
            ...g
          } = e;
          return (0, h.jsxs)(rt, {
            ref: n,
            ...g,
            as: be,
            children: [
              (0, h.jsx)(pe, {
                size: s,
                variant: r,
                disabled: g.disabled,
                bsPrefix: o,
                href: u,
                target: p,
                onClick: d,
                type: i,
                children: a,
              }),
              (0, h.jsx)(rt.Toggle, {
                split: !0,
                id: t,
                size: s,
                variant: r,
                disabled: g.disabled,
                childBsPrefix: o,
                children: (0, h.jsx)("span", {
                  className: "visually-hidden",
                  children: l,
                }),
              }),
              (0, h.jsx)(rt.Menu, {
                role: f,
                renderOnMount: m,
                rootCloseEvent: b,
                flip: x,
                children: c,
              }),
            ],
          });
        });
      (da.propTypes = ca), (da.displayName = "SplitButton");
      const ua = da;
      const pa = t(20347).HK;
      function fa(e, n, t) {
        void 0 === n && (n = u.Hz), void 0 === t && (t = u.cs);
        const o = [];
        return (
          Object.entries(e).forEach((e) => {
            let [s, r] = e;
            null != r &&
              ("object" == typeof r
                ? n.forEach((e) => {
                    const n = r[e];
                    if (null != n) {
                      const r = e !== t ? `-${e}` : "";
                      o.push(`${s}${r}-${n}`);
                    }
                  })
                : o.push(`${s}-${r}`));
          }),
          o
        );
      }
      const ma = {
        bsPrefix: c().string,
        gap:
          ((ba = c().number),
          c().oneOfType([
            ba,
            c().shape({ xs: ba, sm: ba, md: ba, lg: ba, xl: ba, xxl: ba }),
          ])),
      };
      var ba;
      const xa = s.forwardRef((e, n) => {
        let {
          as: t = "div",
          bsPrefix: o,
          className: s,
          direction: r,
          gap: a,
          ...l
        } = e;
        o = (0, u.vE)(o, "horizontal" === r ? "hstack" : "vstack");
        const c = (0, u.pi)(),
          d = (0, u.zG)();
        return (0, h.jsx)(t, {
          ...l,
          ref: n,
          className: i()(s, o, ...fa({ gap: a }, c, d)),
        });
      });
      (xa.displayName = "Stack"), (xa.propTypes = ma);
      const ga = xa;
      var ha = t(94836),
        va = t(12409);
      function ya(e) {
        return "boolean" == typeof e ? (e ? ct.Z : va.Z) : e;
      }
      const ja = {
          id: c().string,
          transition: c().oneOfType([c().oneOf([!1]), c().elementType]),
          mountOnEnter: c().bool,
          unmountOnExit: c().bool,
          generateChildId: c().func,
          onSelect: c().func,
          activeKey: c().oneOfType([c().string, c().number]),
        },
        Na = (e) => {
          let { transition: n, ...t } = e;
          return (0, h.jsx)(ha.Z, { ...t, transition: ya(n) });
        };
      (Na.propTypes = ja), (Na.displayName = "TabContainer");
      const Ca = Na,
        Ea = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "tab-content")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      Ea.displayName = "TabContent";
      const wa = Ea;
      var Ta = t(54865),
        Pa = t(30895);
      const Oa = {
          bsPrefix: c().string,
          as: c().elementType,
          eventKey: c().oneOfType([c().string, c().number]),
          active: c().bool,
          transition: c().oneOfType([c().bool, c().elementType]),
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
          mountOnEnter: c().bool,
          unmountOnExit: c().bool,
          id: c().string,
          "aria-labelledby": c().string,
        },
        ka = s.forwardRef((e, n) => {
          let { bsPrefix: t, transition: o, ...s } = e;
          const [
              { className: r, as: a = "div", ...l },
              {
                isActive: c,
                onEnter: d,
                onEntering: p,
                onEntered: f,
                onExit: m,
                onExiting: b,
                onExited: x,
                mountOnEnter: g,
                unmountOnExit: v,
                transition: y = ct.Z,
              },
            ] = (0, Pa.W)({ ...s, transition: ya(o) }),
            j = (0, u.vE)(t, "tab-pane");
          return (0, h.jsx)(Ta.Z.Provider, {
            value: null,
            children: (0, h.jsx)(mo.Z.Provider, {
              value: null,
              children: (0, h.jsx)(y, {
                in: c,
                onEnter: d,
                onEntering: p,
                onEntered: f,
                onExit: m,
                onExiting: b,
                onExited: x,
                mountOnEnter: g,
                unmountOnExit: v,
                children: (0, h.jsx)(a, {
                  ...l,
                  ref: n,
                  className: i()(r, j, c && "active"),
                }),
              }),
            }),
          });
        });
      (ka.displayName = "TabPane"), (ka.propTypes = Oa);
      const Ra = ka,
        $a = {
          eventKey: c().oneOfType([c().string, c().number]),
          title: c().node.isRequired,
          disabled: c().bool,
          tabClassName: c().string,
          tabAttrs: c().object,
        },
        Za = () => {
          throw new Error(
            "ReactBootstrap: The `Tab` component is not meant to be rendered! It's an abstract component that is only valid as a direct Child of the `Tabs` Component. For custom tabs components use TabPane and TabsContainer directly"
          );
        };
      Za.propTypes = $a;
      const Ia = Object.assign(Za, { Container: Ca, Content: wa, Pane: Ra });
      var Fa = t(89542);
      const Sa = {
        activeKey: c().oneOfType([c().string, c().number]),
        defaultActiveKey: c().oneOfType([c().string, c().number]),
        variant: c().string,
        transition: c().oneOfType([c().oneOf([!1]), c().elementType]),
        id: c().string,
        onSelect: c().func,
        mountOnEnter: c().bool,
        unmountOnExit: c().bool,
        fill: c().bool,
        justify: c().bool,
      };
      function Ba(e) {
        let n;
        return (
          rn(e, (e) => {
            null == n && (n = e.props.eventKey);
          }),
          n
        );
      }
      function Ma(e) {
        const {
          title: n,
          eventKey: t,
          disabled: o,
          tabClassName: s,
          tabAttrs: r,
          id: a,
        } = e.props;
        return null == n
          ? null
          : (0, h.jsx)(ps, {
              as: "li",
              role: "presentation",
              children: (0, h.jsx)(bs, {
                as: "button",
                type: "button",
                eventKey: t,
                disabled: o,
                id: a,
                className: s,
                ...r,
                children: n,
              }),
            });
      }
      const Aa = (e) => {
        const {
          id: n,
          onSelect: t,
          transition: o,
          mountOnEnter: s = !1,
          unmountOnExit: r = !1,
          variant: a = "tabs",
          children: i,
          activeKey: l = Ba(i),
          ...c
        } = (0, d.Ch)(e, { activeKey: "onSelect" });
        return (0, h.jsxs)(ha.Z, {
          id: n,
          activeKey: l,
          onSelect: t,
          transition: ya(o),
          mountOnEnter: s,
          unmountOnExit: r,
          children: [
            (0, h.jsx)(hs, {
              ...c,
              role: "tablist",
              as: "ul",
              variant: a,
              children: sn(i, Ma),
            }),
            (0, h.jsx)(wa, {
              children: sn(i, (e) => {
                const n = { ...e.props };
                return (
                  delete n.title,
                  delete n.disabled,
                  delete n.tabClassName,
                  delete n.tabAttrs,
                  (0, h.jsx)(Ra, { ...n })
                );
              }),
            }),
          ],
        });
      };
      (Aa.propTypes = Sa), (Aa.displayName = "Tabs");
      const La = Aa,
        Ha = { [f.d0]: "showing", [f.Ix]: "showing show" },
        Da = s.forwardRef((e, n) =>
          (0, h.jsx)(ct.Z, { ...e, ref: n, transitionClasses: Ha })
        );
      Da.displayName = "ToastFade";
      const za = Da,
        Ka = s.createContext({ onClose() {} }),
        _a = {
          bsPrefix: c().string,
          closeLabel: c().string,
          closeVariant: c().oneOf(["white"]),
          closeButton: c().bool,
        },
        Ga = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            closeLabel: o = "Close",
            closeVariant: r,
            closeButton: a = !0,
            className: l,
            children: c,
            ...d
          } = e;
          t = (0, u.vE)(t, "toast-header");
          const p = (0, s.useContext)(Ka),
            f = (0, We.Z)((e) => {
              p?.onClose?.(e);
            });
          return (0, h.jsxs)("div", {
            ref: n,
            ...d,
            className: i()(t, l),
            children: [
              c,
              a &&
                (0, h.jsx)(dn.Z, {
                  "aria-label": o,
                  variant: r,
                  onClick: f,
                  "data-dismiss": "toast",
                }),
            ],
          });
        });
      (Ga.displayName = "ToastHeader"), (Ga.propTypes = _a);
      const Va = Ga,
        qa = s.forwardRef((e, n) => {
          let { className: t, bsPrefix: o, as: s = "div", ...r } = e;
          return (
            (o = (0, u.vE)(o, "toast-body")),
            (0, h.jsx)(s, { ref: n, className: i()(t, o), ...r })
          );
        });
      qa.displayName = "ToastBody";
      const Ua = qa,
        Wa = {
          bsPrefix: c().string,
          animation: c().bool,
          autohide: c().bool,
          delay: c().number,
          onClose: c().func,
          onEnter: c().func,
          onEntering: c().func,
          onEntered: c().func,
          onExit: c().func,
          onExiting: c().func,
          onExited: c().func,
          show: c().bool,
          transition: c().elementType,
          bg: c().string,
        },
        Xa = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            className: o,
            transition: r = za,
            show: a = !0,
            animation: l = !0,
            delay: c = 5e3,
            autohide: d = !1,
            onClose: p,
            onEntered: f,
            onExit: m,
            onExiting: b,
            onEnter: x,
            onEntering: g,
            onExited: v,
            bg: y,
            ...j
          } = e;
          t = (0, u.vE)(t, "toast");
          const N = (0, s.useRef)(c),
            C = (0, s.useRef)(p);
          (0, s.useEffect)(() => {
            (N.current = c), (C.current = p);
          }, [c, p]);
          const E = (0, Je.Z)(),
            w = !(!d || !a),
            T = (0, s.useCallback)(() => {
              w && C.current?.();
            }, [w]);
          (0, s.useEffect)(() => {
            E.set(T, N.current);
          }, [E, T]);
          const P = (0, s.useMemo)(() => ({ onClose: p }), [p]),
            O = !(!r || !l),
            k = (0, h.jsx)("div", {
              ...j,
              ref: n,
              className: i()(t, o, y && `bg-${y}`, !O && (a ? "show" : "hide")),
              role: "alert",
              "aria-live": "assertive",
              "aria-atomic": "true",
            });
          return (0, h.jsx)(Ka.Provider, {
            value: P,
            children:
              O && r
                ? (0, h.jsx)(r, {
                    in: a,
                    onEnter: x,
                    onEntering: g,
                    onEntered: f,
                    onExit: m,
                    onExiting: b,
                    onExited: v,
                    unmountOnExit: !0,
                    children: k,
                  })
                : k,
          });
        });
      (Xa.propTypes = Wa), (Xa.displayName = "Toast");
      const Ya = Object.assign(Xa, { Body: Ua, Header: Va }),
        Ja = {
          bsPrefix: c().string,
          position: c().oneOf([
            "top-start",
            "top-center",
            "top-end",
            "middle-start",
            "middle-center",
            "middle-end",
            "bottom-start",
            "bottom-center",
            "bottom-end",
          ]),
          containerPosition: c().string,
        },
        Qa = {
          "top-start": "top-0 start-0",
          "top-center": "top-0 start-50 translate-middle-x",
          "top-end": "top-0 end-0",
          "middle-start": "top-50 start-0 translate-middle-y",
          "middle-center": "top-50 start-50 translate-middle",
          "middle-end": "top-50 end-0 translate-middle-y",
          "bottom-start": "bottom-0 start-0",
          "bottom-center": "bottom-0 start-50 translate-middle-x",
          "bottom-end": "bottom-0 end-0",
        },
        ei = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            position: o,
            containerPosition: s,
            className: r,
            as: a = "div",
            ...l
          } = e;
          return (
            (t = (0, u.vE)(t, "toast-container")),
            (0, h.jsx)(a, {
              ref: n,
              ...l,
              className: i()(t, o && Qa[o], s && `position-${s}`, r),
            })
          );
        });
      (ei.displayName = "ToastContainer"), (ei.propTypes = Ja);
      const ni = ei,
        ti = () => {},
        oi = {
          bsPrefix: c().string,
          type: c().oneOf(["checkbox", "radio"]),
          name: c().string,
          checked: c().bool,
          disabled: c().bool,
          id: c().string.isRequired,
          onChange: c().func,
          value: c().oneOfType([
            c().string,
            c().arrayOf(c().string.isRequired),
            c().number,
          ]).isRequired,
          inputRef: c().oneOfType([c().func, c().any]),
        },
        si = s.forwardRef((e, n) => {
          let {
            bsPrefix: t,
            name: o,
            className: s,
            checked: r,
            type: a,
            onChange: l,
            value: c,
            disabled: d,
            id: p,
            inputRef: f,
            ...m
          } = e;
          return (
            (t = (0, u.vE)(t, "btn-check")),
            (0, h.jsxs)(h.Fragment, {
              children: [
                (0, h.jsx)("input", {
                  className: t,
                  name: o,
                  type: a,
                  value: c,
                  ref: f,
                  autoComplete: "off",
                  checked: !!r,
                  disabled: !!d,
                  onChange: l || ti,
                  id: p,
                }),
                (0, h.jsx)(pe, {
                  ...m,
                  ref: n,
                  className: i()(s, d && "disabled"),
                  type: void 0,
                  role: void 0,
                  as: "label",
                  htmlFor: p,
                }),
              ],
            })
          );
        });
      (si.propTypes = oi), (si.displayName = "ToggleButton");
      const ri = si,
        ai = {
          name: c().string,
          value: c().any,
          onChange: c().func,
          type: c().oneOf(["checkbox", "radio"]).isRequired,
          size: c().string,
          vertical: c().bool,
        },
        ii = s.forwardRef((e, n) => {
          const {
              children: t,
              type: o = "radio",
              name: r,
              value: a,
              onChange: i,
              vertical: l = !1,
              ...c
            } = (0, d.Ch)(e, { value: "onChange" }),
            u = () => (null == a ? [] : [].concat(a));
          return (
            _n()(
              "radio" !== o || !!r,
              'A `name` is required to group the toggle buttons when the `type` is set to "radio"'
            ),
            (0, h.jsx)(be, {
              ...c,
              ref: n,
              vertical: l,
              children: sn(t, (e) => {
                const n = u(),
                  { value: t, onChange: a } = e.props;
                return s.cloneElement(e, {
                  type: o,
                  name: e.name || r,
                  checked: -1 !== n.indexOf(t),
                  onChange: b(a, (e) =>
                    ((e, n) => {
                      if (!i) return;
                      const t = u(),
                        s = -1 !== t.indexOf(e);
                      "radio" !== o
                        ? i(s ? t.filter((n) => n !== e) : [...t, e], n)
                        : s || i(e, n);
                    })(t, e)
                  ),
                });
              }),
            })
          );
        });
      ii.propTypes = ai;
      const li = Object.assign(ii, { Button: ri });
      var ci = t(82580),
        di = t(16310);
      const ui = (e) => {
        let { title: n = "Placeholder", text: t } = e;
        return (0, h.jsxs)("svg", {
          className: "bd-placeholder-img bd-placeholder-img-lg d-block w-100",
          width: "800",
          height: "400",
          xmlns: "http://www.w3.org/2000/svg",
          role: "img",
          "aria-label": `${n}: ${t}`,
          preserveAspectRatio: "xMidYMid slice",
          focusable: "false",
          children: [
            (0, h.jsx)("title", { children: n }),
            (0, h.jsx)("rect", { width: "100%", height: "100%", fill: "#555" }),
            (0, h.jsx)("text", {
              x: "50%",
              y: "50%",
              fill: "#333",
              dy: ".3em",
              children: t,
            }),
          ],
        });
      };
      ui.displayName = "ExampleCarouselImage";
      const pi = ui,
        fi = {
          React: r,
          ...r,
          ...o,
          formik: ci,
          yup: di,
          ExampleCarouselImage: pi,
        };
      delete fi.default;
      const mi = fi;
    },
  },
]);
